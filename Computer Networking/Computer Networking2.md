# 参考

[moon聊技术](https://mp.weixin.qq.com/s/n7TmI6M9Ma_rVnV2GbHUMw)

# 整体性

- Conception：
  1. **OSI七层**：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
  1. **TCP/IP四层**：应用层、传输层、网络层、网络接口层
  1. **五层**：应用层、传输层、网络层、数据链路层、物理层
- Question：
  1. **每一层的作用 ？**
     - 应用层：专注于为用户提供应用功能，不关心数据如何传输，工作在用户态，其下工作在内核态
     - 传输层：为应用层提供数据传输服务，将上层数据分段并提供端到端的，可靠/不可靠的传输；还要负责流量控制等问题
     - 网络层：实际的传输功能，寻址（找到 IP 地址对应的设备，如果找不到设备，就需要路由 导航）+ 路由（找到数据应该往哪里发送 方向盘）功能
     - 数据链路层：为网络层提供链路级别的服务，将网络层传下来的包组成帧
     - 物理层：为数据链路层提供二进制传输的服务，传输bit流
  2. **每一层的常见协议？**
     - 应用层：HTTP、FTP、SMTP、TELNET、DNS
     - 传输层：TCP、UDP
     - 网络层：IP、IPv6、ICMP、ARP、RARP
     - 数据链路层：
  3. **每一层传输的基本数据单元？**
     - 应用层：报文
     - 传输层：段
     - 网络层：包
     - 数据链路层：帧
     - 物理层：bit流
  4. **为什么要分层？**
     - 各层之间相互独立，并不需要知道下一层是如何实现的，仅需要通过接口联系
     - 灵活性好，某一层发生变化时，只要借口不变，其他层不受影响
     - 易于设计实现和标准化
     - 太少每一层协议太复杂，太多各层功能无法分清

# HTTP

- Conception：
  1. HTTP定义
  2. HTTP状态码
  3. HTTP请求方式
  4. HTTP请求/相应报文
  5. HTTP1.0
  6. HTTP1.1
  7. HTTPS（SST/TLS）
  8. HTTP2.0
  9. HTTP3.0
  9. DNS
  10. Cookie/Session
  11. 数字签名、数字证书
  
- Question：
  1. **如何理解HTTP协议？**
  
     - 基于TCP协议实现，超文本传输协议，一个简单的请求-响应协议，超文本（不仅是文字，还有图片、视频、链接）、传输（双向协议、两点之间传输数据）、协议（约定和规范）
  
  2. 说一下HTTP常见的请求方式？
  
  3. **GET/POST区别？**
  
     - GET和POST本质上就是TCP链接，并无区别，由于HTTP规定和浏览器的限制，导致在应用过程中体现出一些不同
  
     - | 区别             | GET                                                          | POST                                               |
       | ---------------- | ------------------------------------------------------------ | -------------------------------------------------- |
       | 数据传输方式     | 从服务器获取数据                                             | 向服务器提交数据                                   |
       | 对数据长度的限制 | 当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符） | 无限制                                             |
       | 对数据类型的限制 | 只允许 ASCII 字符                                            | 无限制                                             |
       | 安全性           | 较差，所发送的数据是 URL 的一部分，会显示在网页上            | 较好 参数不会被保存在浏览器历史或 WEB 服务器日志中 |
       | 可见性           | 显示在 URL 上                                                | 不显示                                             |
       | 收藏为书签       | 可以                                                         | 不可以                                             |
       | 历史记录         | 可以被保留在历史记录当中                                     | 不可以被保留                                       |
       | 缓存             | 能被缓存                                                     | 不可以被缓存                                       |
  
  4. GET请求中URL编码的意义？
  
  5. HTTP状态码？
  
     | 状态码 | 信息                                           |
     | ------ | ---------------------------------------------- |
     | 1xx    | 信息，服务器收到请求，需要请求者继续执行操作   |
     | 2xx    | 成功，操作被成功接收并处理                     |
     | 3xx    | 重定向，需要进一步的操作以完成请求             |
     | 4xx    | 客户端错误，请求包含语法错误或无法完成请求     |
     | 5xx    | 服务器错误，服务器在处理请求的过程中发生了错误 |
  
     - 301 302 500
  
  6. HTTP请求/相应报文格式、常见字段？
  
  7. HTTP请求的完整过程？
  
  8. HTTP1.0问题？
  
  9. HTTP1.1优点？
  
  10. HTTP1.1改进？
  
  11. HTTP1.1问题？
  
  12. 长连接和短连接？（Keep-live）
  
  13. HTTPS做了什么（三点）？
  
  14. HTTPS缺点？
  
  15. HTTP2.0改进？
  
  16. HTTP2.0问题？
  
  17. HTTP3.0改进？
  
  18. **HTTP和HTTPS的区别？**
  
      - HTTP是明文传输，HTTPS在TCP和HTTP中间加入了SSL/TLS安全协议，加密传输
      - HTTP三次握手即可，HTTPS在三次握手后还需要SSL/TLS的三次握手过程
      - HTTP端口号为80，HTTPS端口号为443
      - CA证书：HTTPS协议需要向CA申请数字证书
  
  19. **HTTP1.0和HTTP1.1的区别？**
  
      - 长链接：1.0每一次请求都需要三次握手，并且是串行的请求；1.1新增了长链接
      - 管道：1.0发送一个请求必须等待响应才能发送第二个，1.1新增了管道，同一个TCP链接中可以发出多个请求
      - 断点续传：HTTP1.0不支持，1.1新增了range字段，指定数据字节位置，开始可以断点续传
      - 新增HOST请求头：[CSDN](https://blog.csdn.net/codejas/article/details/82844032)
      - 缓存处理不同：[CSDN](https://blog.csdn.net/weixin_42554191/article/details/106235589)
      - 错误状态码：1.1新增了24个错误状态响应码，如410表示服务器上的资源被永久性删除
  
  20. **HTTP1.1和HTTP2.0的区别？**
  
      - 头部压缩：如果发出多个请求，头部相同，2.0会消除重复的部分
      - 二进制格式：1.1用纯文本，2.0用二进制格式
      - 数据流：2.0数据包不按顺序发送；因此需要数据包标记，指出属于哪个回应，请求回应的数据包称为数据流，每个数据流都做了标记有编号；客户端还可以指定数据流优先级，可以先响应优先级高的
      - 多路复用：2.0可以在一个连接中并发多个请求或响应，解决了队头阻塞问题
      - 服务器推送：1.1服务器只能被动的响应，2.0可以主动向客户端发送消息
  
  21. **HTTP2.0和HTTP3.0的区别？**
  
      - 传输层协议不同：2.0用TCP，3.0用UDP
      - 3.0新增了QUIC（在UDP之上伪TCP+TLS+HTTP2.0的多路复用协议），基于UDP的QUIC可以实现类似TCP的可靠传输
      - 握手次数：2.0基于HTTPS实现，三次握手+三次握手，总共6次；3.0用QUIC只需要3次
  
  22. HTTP2.0和HTTP3.0的区别？
  
  23. HTTP2.0和HTTP3.0的区别？
  
  24. HTTP2.0和HTTP3.0的区别？
  
  25. SSL/TLS
  
  26. SST/TLS握手过程 /HTTPS工作过程/HTTPS原理？
  
  27. Cookie和Session是什么？如何配合？区别？
  
  28. 分布式Session问题？
  
  29. 数字签名、数字证书？

# DNS

- Conception：
  1. 递归查询、迭代查询
  2. 负载均衡、负载分配
  3. 根服务器、顶级域服务器、权威服务器
  4. DNS缓存/域名缓存
- Question：
  1. DNS工作原理？
  2. DNS解析过程？
  3. DNS查询方式？
  4. DNS负载均衡？
  5. DNS域名缓存？

# TCP UDP

- Conception：
  1. TCP/UDP
  2. 三次握手
  3. 四次挥手
  3. TCP保活机制/保活计时器
  4. 超时重传、快速重传
  5. 滑动窗口
  6. 流量控制
  7. 拥塞控制（慢启动、拥塞避免、快速重传、快速恢复）
  8. 半连接、全连接队列
  8. 拆包、粘包
  9. MTU、MSS、RTO、RTT
  10. Socket
- Question：
  1. TCP/UDP区别？
  2. TCP特点、UDP特点 ？
  3. TCP/UDP对应的场景？
  4. TCP/UDP对应的协议？
  5. TCP/UDP头部？
  5. **三次握手（发的是什么报文，有哪些信息，发的进入什么状态，对端收之后不回的进入什么状态）**
     1. **过程**
        - ![](https://mmbiz.qpic.cn/mmbiz_png/9dwzhvuGc8aH30ePA7KibqCYCUwWF2cJqdjHiaLo50zYG9DmAEqRz2ofia9BJN6TyhE14sx7cqickXXJGF5DAyEf6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
        - 第一次：A的TCP进程创建一个传输控制块TCB，向B发送连接请求报文，同部位SYN=1，选择一个初始序列号seq = x，A进入SYN_SENT状态
        - 第二次：B收到连接请求报文段，同步位SYN=1，确认位ACK=1，选择一个初始序列号seq = y，确认号ack = x + 1，B进入SYN_RCVD状态
        - 第三次：A收到B的确认后，再发出确认报文，确认位ACK=1，确认号ack = y + 1，进入ESTABLISHED状态，B收到A的确认报文也进入ESTABLISHED状态
     2. **为什么是三次？**
        - 防止旧的重复连接初始化造成混乱（旧连接比新连接先到，如果两次的话不能根据第二次的ack比较是不是历史报文，三次则可以判断是历史连接则发送RST终止本次连接）
        - 同步序列号：三次确保双方的初始序列号都被对方接收，被可靠的同步
        - 避免资源浪费：三次是最小值
     3. 为什么不是两次?
     4. 为什么不是四次？
     5. 第一二三次丢包各会发生什么？
  6. **四次挥手**
     1. **过程？**
        - ![](https://mmbiz.qpic.cn/mmbiz_png/9dwzhvuGc8aH30ePA7KibqCYCUwWF2cJqAdOnS8hnGEptDFjARQte3BuxA4ETMH1xBiaR1yGlF4TDRWGeKicrbL1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
        - 第一次：A发送一个连接释放报文，终止控制位FIN = 1，确认位ACK = 1，序列号seq = x，进入FIN_WAIT_1状态
        - 第二次：B发送确认报文段，确认位ACK = 1，ack = x + 1，进入CLOSE-WAIT状态，A收到后进入FIN_WAIT_2状态
        - 第三次：B发送连接释放报文（处理完数据之后），终止控制位FIN = 1，确认位ACK = 1，seq = y，ack = x + 1，B进入LAST_ACK状态
        - 第四次：A发送确认报文段，确认位ACK = 1，ack = y + 1，A进入TIME_WAIT状态，B收到后进入CLOSED状态
     2. 为什么四次？
     3. TIME_WAIT为什么2MSL？/为什么要等待2MSL?
     4. TIME_WAIT太多怎么办？
     5. TIME_WAIT是服务器还是客户端的状态？
  8. TCP如何保证的可靠性？
  9. TCP保活机制/保活计时器？（keeplive）
  10. 超时重传、快速重传？
  11. 为什么快速重传选择3次ACK？（阿秀80）
  12. 滑动窗口？
  13. 流量控制？
  14. 拥塞控制（慢启动、拥塞避免、快速重传、快速恢复）？
  15. 半连接队列、全连接队列？
  16. 拆包、粘包？
  17. 一些名词：MTU、MSS、RTO、RTT？
  18. 如何优化三次握手、四次挥手（小林）？
  15. Socket见网络编程

# IP

- Conception：
  1. ABCDE五类地址
  2. 子网掩码
  3. ARP、RARP、DHCP、ICMP
- Question：
  1. IP地址分类？
  2. **Ping的作用？**
     - 测试在两台主机之间能否建立连接，向目的主机发送多个ICMP回送请求报文，没有响应则无法建立链接，有响应可以根据目的主机返回的回送报文的时间和响应的次数估算出数据包往返时间及丢包率
  3. ARP协议的工作原理？
  4. 对ARQ协议的理解？
  4. RARP工作原理？

# 安全性问题

- Conception：
  1. SYN洪泛攻击
  2. DDos攻击（Distributed Denial of Service）
  3. XSS攻击（cross-site scripting）
  4. SQL注入
  5. CSRF攻击
- Question：
  1. SYN洪泛攻击？
  1. DDos攻击？
  2. Xss攻击？
  3. SQL注入？
  4. CSRF攻击？

# 遗留问题

- 服务器缓存？（阿秀9）

