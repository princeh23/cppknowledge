# 参考文章

- 程序员库森
- [CSDN Redis面试题](https://blog.csdn.net/zhaoxi2020/category_11053951.html?spm=1001.2014.3001.5482)
- [CSDN几率大的Redis面试题（待看...）](https://blog.csdn.net/Butterfly_resting/article/details/89668661)

# 整体

- Conception：

  1. Redis、Memcached

- Question：

  1. **什么是Redis？**

     -  本质上是一个key-value类型的数据库，和memcached类似，加载到内存中进行操作，纯内存操作，性能出色，是已知的性能最快的key-value数据库
     - 优点：
       - 读写性能出色
       - 数据结构丰富
       - 支持数据持久化，AOF、RDB两种
       - 支持事务，所有操作是原子性的，可以通过MULTI和EXEC指令
       - 支持主从复制、读写分离
     - 缺点：
       - 内存有限，不适合海量数据的高性能读写
       - 宕机会导致从机未能及时同步

  1. **Redis和Memcached相比？**

     - |          | Memcached          | Redis                               |
       | -------- | ------------------ | ----------------------------------- |
       | 数据类型 | 简单的字符串       | string、list、hash、set、sorted set |
       | 持久化   | 不支持             | AOF、RDB                            |
       | 网络IO   | 非阻塞IO           | IO多路复用                          |
       | 集群模式 | 没有原生的集群模式 | 主从同步                            |

  1. **Redis为什么这么快？** 

     -  使用内存存储，没有磁盘IO的开销
     - 单线程处理请求，避免线程切换和锁资源的开销
     - 使用IO多路复用技术，使用epoll
     - 数据结构丰富，可以直接应用的优化数据
     - 冷热数据分离，热数据在内存中，冷数据在磁盘

  1. **为什么用Redis做缓存？**

     - 高性能
       - 热点数据直接操作缓存，速度快
     - 高并发
       - 缓存支持的并发数比数据库多，把数据库中的部分数据转移到缓存中，部分请求直接访问缓存

  1. **Redis应用场景？**

     - 缓存
     - 排行榜
     - 计数器：点击量、播放数
     - 分布式
     - 社交网络中的点、踩

# 数据类型

- Conception：
  1. 数据类型：底层实现
  2. string：SDS
  3. list：双向链表、压缩链表
  4. hash：压缩链表、哈希表/字典、
  5. set：哈希表/字典、整数集合
  6. zset：压缩链表、跳表
  7. GEO、Bitmap、HyperLogLog
  8. quicklist（双向链表）、listpack（压缩链表）
- Question：
  1. **八种数据类型？应用场景？**
  
     - String：二进制安全、可以包含任何数据，比如jpg图片或者序列化的对象（常规计数）
  
     - List：简单的字符串列表，按照插入顺序排序（最新回复）
  
     - Hash：键值对集合（）
  
     - Set：无序的去重集合（共同好友、共同关注）
  
     - SortedSet：可排序版的set（排行榜）
  
     - Bitmap：位图，一个以位为单位的数据
  
     - Hyperloglog：统计基数，有误差
  
     - Geospatial：地理位置信息（打车定位）
  
     - ```cpp
       SET runoob "菜鸟教程"
       GET runoob
       
       HMSET runoob field1 "Hello" field2 "World"
       HGET runoob field1
       
       lpush runoob redis
       lpush runoob mongodb
       lpush runoob rabbitmq
       lrange runoob 0 10
           
       sadd runoob redis
       sadd runoob rabbitmq
       smembers runoob
           
       zadd runoob 0 redis
       zadd runoob 0 mongodb
       ZRANGEBYSCORE runoob 0 1000
       ```

# 2种持久化

- Conception：
  1. AOF（Append Only File）
  2. AOF重写
  3. RDB（Redis DataBase）
  4. 混合持久化
- Question：
  1. **AOF、优点、缺点？**
     - 定义：以日志的形式记录每个操作，记录写指令不记录读指令，只许追加文件不允许修改，AOF保存的是appendonly.aof文件，恢复的时候从前到后执行一次
     - AOF重写：一直追加写文件会又来越大，重写机制可以进行文件压缩，只保留可以恢复数据的最小指令集
     - 机制：每次修改同步、每秒同步、不同步
     - 缺点：aof文件大，恢复速度慢；aof运行效率比rdb慢，每秒同步效率好
  1. **RDB、优点、缺点？**
     - 定义：指定时间间隔将数据快照写入磁盘，恢复的时候将快照文件直接读入内存
     - 优点：适合大规模、对数据完整性、一致性要求不高
     - 缺点：每隔一段时间才备份，Redis宕机的话会丢失数据
  1. **如何选择？**
     - 对数据不敏感，可以关闭持久化
     - 可以承受数分钟的损失，如做缓存，只开RDB
     - 做内存数据库，RDB、AOF都开启，RDB时候做数据备份，AOF保证数据不丢失
  1. **混合持久化？**
     - Redis4.0
     - 前半段是RDB格式全量数据，后半段是AOF增量数据
     - 优点：绝大部分是RDB，加载速度快，增量是AOF，避免了数据丢失
     - 缺点：兼容性差，Redis4.0之前不识别该aof文件；阅读性差，前半段是RDB
  1. **Redis持久化数据和缓存怎么做扩容？**
     - 如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。
     - 如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话（即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。
     - **看参考文章CSDN里有很多Redis面试题**

# 3种过期键删除策略

- Conception：
  1. 定时删除
  2. 惰性删除
  3. 定期删除
- Question：
  1. **过期键的删除策略？**
  
     - |      | 定时删除             | 惰性删除                     | 定期删除                          |
       | ---- | -------------------- | ---------------------------- | --------------------------------- |
       | 方法 | 设置定时器，到时删除 | 过期不删除，再次访问时候检查 | 每隔一段时间对一部分键进行检查    |
       | 优点 | 对内存优化           | 对CPU友好                    | 减少了对CPU的影响，释放了部分内存 |
       | 缺点 | 对CPU不友好          | 对内存不友好，造成内存泄露   | 难以衡量定时时长                  |
  
  2. **过期时间和永久有效怎么设置？**
  
     - EXPIRE、PEXPIRE：设置生存时间（秒/毫秒精度）
     - EXPIREAT、PEXPIREAT：设置过期时间（秒/毫秒精度）

# 删除/替换/内存淘汰/回收策略 

- Concetion：
  1. noeviction
  2. volatile-lru、volatile-random、volatile-ttl、volatile-lfu
  3. allkeys-random、allkeys-lru、allkeys-lfu
  4. Redis4.0新增：两种lfu
- Question：
  1. **内存淘汰策略？**
     - 没有设置过期时间的数据越来越多，内存不够用时候需要进行淘汰
     - 不进行数据淘汰：noevction（不进行内存淘汰，返回错误）
     - 在设置了过期时间的数据种进行淘汰：volatile-ttl（越早过期越先删除）、volatile-random、volatile-lru、volatile-lfu
     - 在所有数据范围内进行淘汰：allkeys-random、allkeys-lru、allkeys-lfu
     - 优先使用allkeys-lru

# 缓存问题

- Conception：
  1. 缓存和数据库的数据不一致
  2. 缓存雪崩
  3. 缓存击穿
  4. 缓存穿透
  5. 缓存预热、缓存降级
- Question：
  1. **缓存异常四种类型？**
     - 缓存与数据库的数据不一致
     - 缓存雪崩
     - 缓存击穿
     - 缓存穿透
  2. **缓存与数据库的数据不一致？**
     - 方案：
       - 先更新数据库，再更新缓存
         - 问题：并发场景下，会将脏数据刷到缓存
       - 先更新缓存，再更新数据库
         - 数据库更新失败则数据不一致
       - **先删除缓存，再更新数据库**
         - 存在问题：A删除缓存；B查询缓存没查到；B从数据库种读到之后将旧数据写入缓存；A更新数据库
         - 解决：延时双删：删除->更新->sleep->删除（删除B写入的旧数据）
       - **先更新数据库，再删除缓存**
         - 存在问题：删除缓存阶段出现错误
         - 解决：加入消息队列，将需要删除缓存的任务加入消息队列，直到删除成功才从消息队列种删除
  3. **缓存雪崩？**
     - 定义：大量key失效/缓存宕机，大量访问请求打在数据库上，数据库宕机
     - 解决：均匀过期，加上小的随机数；服务降级（非核心数据不允许访问数据库）；服务熔断（暂停访问）；使用主从集群；
  4. **缓存击穿？**
     - 定义：某个热key失效，大量请求打在数据库上
     - 解决：热点数据不过期；缓存失败后使用互斥锁或者队列控制阻止对热key的访问
  5. **缓存穿透？**
     - 定义：缓存和数据库种都没有需要的key，数据库压力过大
     - 解决：使用布隆过滤器判断key是否存在，不存在不允许访问数据库；缓存空值，不存在的值在缓存直接返回
  6. **缓存预热？**
     - 定义：系统上线前，提前将缓存数据加载到缓存中，避免开始对数据库的大量访问
  7. **缓存降级？**
     - 定义：对于非核心数据自动降级，不去数据库查询，返回默认值，保证核心服务可用

# 部署方式/高可用方案（单机、主从、Sentinel、Cluster）

- Conception：
  1. 单机模式
  2. 主从
  3. 读写分离
  4. Sentinel哨兵
  5. 主观下线、客观下线
  6. Cluster集群
  7. Redis自研
- Question：
  1. **Redis常见的使用方式？**
     - 单机
     - 主从：
       1. 定义：master -- slave   master挂掉之后，手动指定新的master；读写分离
       2. **主从第一次同步**：采用全量复制
          - 启动一个slave node时候，发送一个PSYNC命令给master
          - 生成RDB，后续的操作写入缓存，slave先将RDB写入磁盘再同步缓存信息
       3. **从库可以分担主库全量复制的压力**
          - 主从全量复制对于主库来说压力大
          - 可以让从库对新来的slave进行同步
       4. **断点续传、网络断了怎么办**
          - repl_backlog_buffer是一个环形缓冲区，master和slave会记录自己写到和读到的位置
          - 重连后判断master_backlog_buffer和slave_backlog_buffer之间的差距
          - 问题：环形可能导致覆盖，合理设置repl_backlog_buffer的大小
       5. slave不会过期key，只会等待master过期key发送del命令
     - Sentinel：
       1. 定义：哨兵选举新的master，但是每个节点存储的数据是一样的，浪费空间
       2. **哨兵职责**：
          - 监控：每秒向主从库发送PING命令，超时标记为下线（主观下线），当有 **N/2 + 1** 个哨兵判断才能**客观下线**
          - 选主：按照断开连接的时长、优先级、复制进度、ID号大小进行选主（原主库需要**清空**本地数据，再和新主库进行全量同步）
          - 通知：把新主库的信息发送给其他从库
       3. **哨兵之间、哨兵和从库如何相互发现？**
          - pub/sub机制，发布/订阅机制
          - 通过订阅主库的"\_\_sentinel\_\_:hello"频道进行相互发现
          - 哨兵向主库发送INFO命令获得从库信息
       4. **由哪个哨兵进行主从切换？**
          - 任何一个哨兵发现主观下线后，向其他哨兵发送信息，其他哨兵的Y票需要超过半数并且>=配置的quorum值
       5. 哨兵数量要>=3，2个哨兵时1个挂了没办法选主
       6. **脑裂**
          - 定义：同时有两个主节点 ，都能接收写请求
          - 问题：往不同的主节点上写入数据，导致数据丢失（原主库会先**清空数据**再全量同步）
          - 解决：min-slaves-to-write（只要有几个slave）和min-slaves-max-lag（主从复制延迟不能超过多少s），原主库从而被限制接收客户请求
     - Cluster：
       1. 所有master的容量总和就是可缓存的总容量，n主n从
       2. **如何分配？**
          - 固定16384个哈希槽，对于n个节点各分配16384/n个槽
          - 每个槽对应的节点会在存储到客户端
          - 对于键值对使用RCR16计算一个值对16384取模
       3. **槽对应的节点变化了怎么办？**
          - 已经转移完：返回MOVED，对新的节点进行访问
          - 正在转移：返回ASK，客户端需要向新节点发送ASKING（新节点允许客户端接下来发送的命令）
       4. **Cluster中节点通信的机制？**
          - gossip协议（包括ping，pong，meet，fail等等）
          - 节点之间不断通信，保证整个集群所有节点的数据是完整的

# 事务

- Conception：

  1. 相关命令
- Question：
  1. **相关命令**
  
     ```mysql
     //如果EXEC之前balanced被 其他客户端 改动，EXEC失败
     WATCH balanced 
     
     //开启事务
     MULTI
     //事务命令
     ...
     ...
     //执行事务
     EXEC
     
     
     //取消事务
     DISCARD 
     //取消监控
     UNWATCH
     ```
  
  2. **Redis中的事务？**
  
     - 原子性：
       - 批量的事务命令会全部执行，或者全部不执行；但是中间某条命令发生**语法错误**也不会退出事务，后面的命令继续执行；不会回滚
       - 命令错误会导致EXEC报错，语法错误EXEC之后全部执行
       - 事务执行过程中不会被客户端的其他命令中断
     - 隔离性：
       - 单进程程序，保证了执行事务时不会被中断
     - 一致性：
       - 数据库执行前是一致的，事务执行只会，数据库也是一致的
     - 持久性：
       - 开启AOF、RDB时支持持久性
  
  3. **Redis为什么不支持回滚？**
  
     - Redis只会因为**语法错误失败/命令用在了错误的键上**而失败，入队时候不能发现，这些问题是由于编程错误（程序员自己的错误，没有机制能避免程序员自己造成的错误），应该在开发过程中发现，而不应该出现在生产环境中
     - 不支持回滚可以保证Redis的简单快速
  
  4. **Redis事务的其他实现？**
  
     - Lua脚本：Redis保证脚本内的命令都执行，也不提供回滚，部分命令错误也依旧执行
     - 中间标记变量判断是否完成：编写复杂

# 单线程、Redis6.0多线程

- Conception：
  1. 单线程
  2. Redis6.0多线程
- Question：
  1. **Redis为何选择单线程？**

     - 数据库是IO密集型而不是CPU密集型，Redis几乎是纯内存操作，执行速度快，真正的瓶颈在于网络I/O，Redis使用单线程的I/O多路复用来解决
     - 单线程一些好处：
       - 避免切换线程的上下文开销
       - 避免加锁的开销
       - 单线程简答可维护

  2. **Redis真的是单线程？**

     - Redis6.0之前：核心网络模型使用单线程，对耗时的命令使用多线程异步化操作（Redis4.0）
     - Redis6.0之后：执行命令是单线程，处理网络数据的读写和协议的解析是多线程I/O

  3. **Redis6.0为何引入多线程？**

     - 问题：I/O瓶颈明显，线上流量变大
     - 解决方法：网络的I/O优化：零拷贝/DPDK技术（有局限不适用于Redis的复杂网络I/O场景）、多核优势
     - 好处：充分利用CPU资源，分担I/O读写负荷

  4. **Redis6.0多线程性能如何？**

     - 几乎翻倍

  5. **Redis的线程模型？**

     - Redis6.0之前

       ![img](https://img2020.cnblogs.com/blog/1031302/202011/1031302-20201109111704406-733348823.png)

     - Redis6.0之后

     - 流程如下：

       - 主线程获取 socket 放入等待列表
       - 将 socket 分配给各个 IO 线程（并不会等列表满）
       - 主线程**阻塞**等待 **IO 线程（多线程）**读取 socket 完毕
       - 主线程执行命令 - **单线程**（如果命令没有接收完毕，会等 IO 下次继续）
       - 主线程**阻塞**等待 **IO 线程（多线程）**将数据回写 socket 完毕（一次没写完，会等下次再写）
       - 解除绑定，清空等待队列

     - 特点如下：

       - IO 线程要么同时在读 socket，要么同时在写，**不会同时读或写**
       - IO 线程只负责读写 socket 解析命令，**不负责命令处理**（主线程串行执行命令）
       - IO 线程数可自行配置

       

       ![img](https://img2020.cnblogs.com/blog/1031302/202011/1031302-20201109104625665-1682010410.png)

  6. **Redis6.0是否默认开启多线程？**

     - 否，在conf文件进行配置
     - io-threads-do-reads yes
     - io-threads 线程数
     - 官方建议：4 核的机器建议设置为 2 或 3 个线程，8 核的建议设置为 6 个线程，线程数一定要小于机器核数，尽量不超过8个。

  7. **多线程是否存在线程安全问题？**

     - 不会，多线程只复杂网络数据读写和协议解析，执行命令依旧是单线程

  8. **Redis6.0和Memcached多线程对比？**

     - 相同点：都用了Master-Worker模型

       ![Master-Worker工作原理](https://img-blog.csdn.net/20171225014840369?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdW5zY2RmMTE3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

     - 不同点：

       - Memcached逻辑处理也在Worker线程，模型简单并且实现了线程隔离
       - Redis的逻辑处理依旧又交还在Master线程，模型复杂度增加但是线程并发安全问题解决

  9. [Redis6.0讲解文章](https://www.cnblogs.com/gz666666/p/12901507.html)

# 分布式锁

- Conception：
  1. 相关命令
  2. Redis、MySQL、Zookeeper分布式锁
  3. RedLock
- Question：
  1. 相关命令：
     - SETNX
     - DEL
     - EXPIRE

# 优化

- Question：
  1. 如何提高 Redis 命中率？
  2. 怎么优化 Redis 的内存占用？

# todo

- 容灾