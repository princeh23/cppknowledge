# 数据结构

## 树

### 二叉树

### 完全二叉树

1. 全满，最后一层集中在左侧

### 二叉搜索树

1. 中序遍历是一个有序序列

### AVL（平衡二叉树）

1. 为什么要有AVL？
   - 避免二叉搜索树退化为链表
2. 定义：
   - 平衡的二叉搜索树
   - 任意节点的左右子树之差不超过1
3. [景禹 插入](https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647521381&idx=1&sn=796ac1eda0eaefadfb57a1b9742bcec0&scene=21#wechat_redirect)
4. [景禹 删除](https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647521508&idx=1&sn=ff0751a1a49a48450757b53978fcbef8&scene=21#wechat_redirect)

### 红黑树

1. 为什么要有？
   - AVL平衡规则太过严格，每次操作几乎都涉及左旋右旋
   - 红黑树在平衡的条件下查找为O(logn)
2. 定义：
   - 节点是红红色或黑色
   - 根是黑色
   - 叶子是黑色且是NULL
   - 红色节点的左右子节点是黑色/不能有两个连续的红色节点
   - 从任一节点到每个叶子节点路径上包含的黑色节点数量一样/红黑树中最长路径最多是最短路径的两倍
3. 时间复杂度 O(logn)
4. [景禹 插入](https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647521642&idx=1&sn=dda12824118e46c17374333062e37a6a&scene=21#wechat_redirect)
5. [景禹 删除](https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647521911&idx=1&sn=2e0a8b636cff515c5471f9a1bb2c3022&scene=21#wechat_redirect)

### B/B-树

1. 为什么要有B树？
   - 多叉树、减少磁盘IO操作，大多数平衡树需要O(h)次磁盘访问操作，每个节点可以包含多个键，降低了B树的高度
2. 定义（m阶的B树）：
   - 每个节点最多有m个节点
   - 除根节点和叶子节点外，每个节点至少要有m/2个孩子
   - 如果根节点不是叶子节点，至少有2个孩子（除非B树只有一个节点）
   - 所有的叶子节点位于同一层，叶子节点不再指向任何节点
   - 每个中间节点有**k-1个元素和k个孩子**

### B+树

1. 为什么要有B+树？
   - B树的每一个节点还存指向数据的指针，B+树只有关键字，每次磁盘能读取更多的数据
   - 查询稳定，每次都要查询到叶子节点
   - B+树叶子节点有指针，适合范围查询，B树需要中序遍历
2. 定义：
   - 所有数据存在叶子节点，所有叶子节点数据从小到大顺序链接
   - 每个中间节点**k个元素和k个孩子**
3. [景禹 查找](https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647522076&idx=1&sn=c00a03c27020c08b857620aa823313ae&scene=21#wechat_redirect)
4. [景禹 插入删除](https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647522108&idx=1&sn=293d99ee10a76798d6a8e6ce5d22198a&scene=21#wechat_redirect)

## 堆

- 一个完全二叉树
- 插入：满足完全二叉树的需求所以放在最后，进行up
- 删除：满足完全二叉树的需求所以堆顶与最后一个元素交换，进行down

## 跳表

- O(logn)
- 查找
- 插入：抛硬币随机决定有几层
- 删除
- [参考](https://blog.csdn.net/tiandesheng111/article/details/39756241?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164259486716781683927434%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164259486716781683927434&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-39756241.first_rank_v2_pc_rank_v29&utm_term=%E8%B7%B3%E8%A1%A8%E9%9D%A2%E8%AF%95&spm=1018.2226.3001.4187)

# 算法

## 十大排序

### 排序基本问题

- 就地排序
- 内部/外部排序
- 稳定排序
- 任何排序算法都可以通过指定方式变的**稳定**

### 冒泡排序

- 交换相邻的元素，每次把最大的放在最后

- ```cpp
  vector<int> bubbleSort(vector<int> arr){
      for(int i = 0; i < arr.size(); i++){
          bool flag = false;
          for(int j = 0; j < n - i - 1; j++){
              if(arr[j] > arr[j+1]){
                  swap(arr[j], arr[j + 1]);
                  flag = true;
              }
          }
          if(flag == false) break;
      }
      return arr;
  }
  ```

- 稳定排序、原地排序
- 最差O(n)、最好O(n^2)
- 拓展
  1. 优化：代码中的flag，如果数组整个已经有序，数组有序就退出
  2. 再优化：后半部分可能已经有序，每次可以更新j循环的右边界
  3. 使用递归实现冒泡排序
  4. 使用两个栈实现冒泡排序
  5. 对链表进行冒泡排序（交换值or交换节点）
- [景禹 参考](https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647522573&idx=1&sn=b6fb02f17742d1f58f1a03c7c1e06dd6&scene=21#wechat_redirect)

### 选择排序

- 选一个最小的和前面的交换

- ```cpp
  vector<int> insertionSort(vector<int> arr){
      if(arr.size() == 0) return arr;
      for(int i = 0; i < arr.size(); i++){
          int min = arr[i];
          for(int j = i + 1; j < arr.size(); j++){
              if(arr[j] < min) min = arr[j];
          }
          swap(arr[i], min);
      }
      return arr;
  }
  ```

- 不稳定排序（模拟441）、原地排序
- 拓展如何变的稳定：每次交换之后，其他元素向后移
- [景禹 参考](https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647522228&idx=1&sn=244c07771e9881af454c60fefc42bb40&scene=21#wechat_redirect)

### 插入排序

- 

### 希尔排序

### 归并排序



### 快速排序

-  选>=pivot和<=pivot的元素进行交换

- ```cpp
  void quickSort(vector<int> arr, int l, int r)
  {
      if (l >= r) return;
  
      int i = l - 1, j = r + 1, x = arr[(l + r ) / 2];
      while (i < j)
      {
          do i ++ ; while (arr[i] < x);
          do j -- ; while (arr[j] > x);
          if (i < j) swap(arr[i], arr[j]);
      }
      quick_sort(arr, l, j), quick_sort(arr, j + 1, r);
  }
  ```

- 不稳定排序、原地排序

### 快速排序变种、快速选择

- 

### 堆排序

### 计数排序

### 桶排序

### 基数排序

