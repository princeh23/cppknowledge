# 树

## 二叉树

## 完全二叉树

1. 全满，最后一层集中在左侧

## 二叉搜索树

1. 中序遍历是一个有序序列

## AVL（平衡二叉树）

1. 为什么要有AVL？
   - 避免二叉搜索树退化为链表
2. 定义：
   - 平衡的二叉搜索树
   - 任意节点的左右子树之差不超过1
3. [景禹 插入](https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647521381&idx=1&sn=796ac1eda0eaefadfb57a1b9742bcec0&scene=21#wechat_redirect)
4. [景禹 删除](https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647521508&idx=1&sn=ff0751a1a49a48450757b53978fcbef8&scene=21#wechat_redirect)

## 红黑树

1. 为什么要有？
   - AVL平衡规则太过严格，每次操作几乎都涉及左旋右旋
   - 红黑树在平衡的条件下查找为O(logn)
2. 定义：
   - 节点是红红色或黑色
   - 根是黑色
   - 叶子是黑色且是NULL
   - 红色节点的左右子节点是黑色/不能有两个连续的红色节点
   - 从任一节点到每个叶子节点路径上包含的黑色节点数量一样/红黑树中最长路径最多是最短路径的两倍
3. 时间复杂度 O(logn)
4. [景禹 插入](https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647521642&idx=1&sn=dda12824118e46c17374333062e37a6a&scene=21#wechat_redirect)
5. [景禹 删除](https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647521911&idx=1&sn=2e0a8b636cff515c5471f9a1bb2c3022&scene=21#wechat_redirect)

## B/B-树

1. 为什么要有B树？
   - 减少磁盘IO操作，大多数平衡树需要O(h)次磁盘访问操作，每个节点可以包含多个键，降低了B树的高度
2. 定义（m阶的B树）：
   - 每个节点最多有m个节点
   - 除根节点和叶子节点外，每个节点至少要有m/2个孩子
   - 如果根节点不是叶子节点，至少有2个孩子（除非B树只有一个节点）
   - 所有的叶子节点位于同一层，叶子节点不再指向任何节点
   - 有x个孩子的节点有x - 1个关键码
3. 1

## B+树

1. 112
2. 

- Question：
  1. 为什么有了二叉搜索树还要有AVL？
     - 避免二叉搜索树退化为链表
  2. 为什么有了二叉搜索树/AVL还要有红黑树？
     - AVL要求太严格，每次都要左旋右旋

# 堆

- 一个完全二叉树
- 插入：满足完全二叉树的需求所以放在最后，进行up
- 删除：满足完全二叉树的需求所以堆顶与最后一个元素交换，进行down

# 跳表

- O(logn)
- 查找
- 插入：抛硬币随机决定有几层
- 删除
- [参考](https://blog.csdn.net/tiandesheng111/article/details/39756241?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164259486716781683927434%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164259486716781683927434&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-39756241.first_rank_v2_pc_rank_v29&utm_term=%E8%B7%B3%E8%A1%A8%E9%9D%A2%E8%AF%95&spm=1018.2226.3001.4187)

# 排序

## 冒泡排序

