# 基础

- Conception：
  1. C和C++区别、和Java区别、和python区别
  1. 预处理、编译、汇编、链接
  2. 动态链接、静态链接
  3. 动态编译、静态编译
  4. 动态联编、静态联编
  5. 动态绑定、静态绑定
- Question：
  1. **C和C++有什么区别**？
     - C++是面向对象的语言，C是面向过程的语言
     - C++引入new/delete的概念，取代了C中malloc/free的概念
     - C++引入引用，C没有
     - C++引入类，C没有
     - C++引入函数重载，C没有
  2. C++和Python的区别？
  3. C++和Java的区别？
  4. **动态链接、静态链接？**
     - 动态链接：通过记录一系列符号和参数，程序运行时将信息传递给操作系统，操作系统将需要的动态库加载到内存中，运行时链接
       - 优点：共享一个动态库，节省资源
       - 缺点：运行时加载，影响性能
     - 静态链接：编译链接时直接将执行的代码拷贝到调用处
       - 优点：不用依赖库，可以独立执行
       - 缺点：体积大；静态库更新需要重新链接

# C++基础语法

- Conception：
  
  1. **定义相关**
  2. 声明、定义
  3. 全局变量、局部变量
  4. **指针相关**
  5. 指针、引用
  6. 函数传递参数（形参、实参  值传递、指针传递、引用传递）
  7. 悬挂指针、野指针
  8. 指针常量、常量指针
  9. 指针数组、数组指针
  10. 函数指针
  11. **关键字相关**
  12. static
  13. #define 
  14. typedef
  15. const 指针常量、常量指针 顶层const、底层const
  16. volatile、mutable、explicit
  17. inline
  18. #ifdef、#else、#endif、#ifndef
  19. **函数相关**
  20. sizeof、strlen
  21. strcpy、sprintf、memcpy
  22. **其他**
  23. extern"C"
  18. 异常处理（try catch throw exception类）
  
- Question：

  1. **声明、定义？**

     - 声明：不分配地址；可以多个地方声明
     - 定义：分配地址和存储空间；只能定义一次
     - extern int  a：修饰的是变量的**声明**，此变量将在文件外/后面进行定义
  
  2. **全局变量和局部变量有什么区别？操作系统和编译器怎么知道？**
  
     - 全局变量：整个程序都可以访问；程序运行结束释放；存放在全局数据段
     - 局部变量：所在模块可以访问；函数调用完毕局部变量消失，内存释放；分配在堆栈
     - 操作系统和编译器根据内存分配位置判断
  
  3. **指针和引用？**
  
     |                                    | 指针                   | **引用**             |
     | ---------------------------------- | ---------------------- | -------------------- |
     |                                    | 拥有自己的空间         | 只是一个别名         |
     | sizeof大小                         | 4                      | 被引用对象的大小     |
     | 参数传递                           | 必须解引用才能操作对象 | 直接可以修改         |
     | **const**                          | **有const指针**        | **没有const引用**    |
     |                                    | 可以指向别的对象       | 不能被改变           |
     |                                    | 多级指针               | 只有一级             |
     | **返回动态内容分配的对象或者内存** | 必须用指针             | 引用可能引起内存泄露 |
  
  4. **数组中a和&a有什么区别？**
  
     - ```cpp
       int a[10]; 
       int (*p)[10] = &a;
       
       a是数组名，也是数组元素首地址;
       a+1表示地址+1，表示a[1]的地址;
       *(a + 1) = a[1];
       
       &a是数组的指针，类型为int (*)[10]（数组指针）
       &a + 1表示数组首地址加上整个数组的偏移，表示a尾元素再下一个元素的地址
       ```
  
  5. **指针相关（常量指针/指针常量、悬挂指针/野指针、指针数组/数组指针、函数指针）**
  
     - **5-1常量指针和指针常量？**
  
       - 常量指针：
  
         - 常量是指针？×
         - 所以不能用这个指针修改变量值，原来的声明可以修改值
         - const * 常量 指针
  
         ```cpp
         const int *p;
         int const *p;
         ```
  
       - 指针常量：
  
         - 指针是常量？√
         - 所以指针指向的东西不能改变：指向哪个变量就是哪个，不能修改
         - \* const 指针 常量
  
         ```cpp
         int *const p;
         ```
  
     - **5-2悬挂指针和野指针？**
  
       - 悬挂指针：指针所指对象已经被释放
       - 野指针：未初始化的指针
  
     - **5-3数组指针、指针数组？**
  
       - http://c.biancheng.net/view/335.html
  
     - **5-4函数指针？**
  
       ```cpp
       //函数指针
       int (*fp)(int , int) = f;
       (*fp)(a, b);
           
       //返回值为指针
       int * fp(int , int)
       ```
       
       - ((void()())0)()什么含义？
         - void (\*)()：函数指针；无参数返回值为空*
         - ( void (*)() ) 0：把0强制转换成函数指针类型，一个函数存在首地址为0的一块区域内
         - ( void ()() ) 0：取0地址开始的一段内存中的内容，内容也就是函数的内容
         -  (void()()) 0 )()：函数调用
  
  6. **static关键字？**
  
     - 修饰局部变量：静态存储区分配内存；首次函数调用中初始化，之后的函数调用不再初始化；局部作用域内可见
     - 修饰全局变量：静态存储区分配内存；整个文件内可见，文件外不可见
     - 修饰函数：整个文件可以，文件外不可见；避免函数同名冲突
     - 修饰成员变量：所有对象共享；类外初始化；不需要对象实例化就可以访问
     - 修饰成员函数：不能接受this指针，只能访问静态成员；不需要对象实例化就可以访问
     - C和C++中的区别：C只能修饰局部变量和全局变量、函数，C++还能修饰成员变量和成员函数
  
  7. **inline**
  
     - 优点
       - 调用地方展开，省去调用时间，提高效率
       - 相比#define宏函数，代码展开时会进行语法安全检查或数据类型转换，更加安全
     - 缺点
       - 代码膨胀，开销大
       - 如果内联函数本身执行时间长，效率提升小
       - 修改内联函数，所有调用内联函数的文件必须重新编译
     - 内联声明只是建议，是否内联由编译器决定，实际不可控
  
  8. **const**
  
     - **8-1常量指针、指针常量**
  
       - 常量指针：
  
         - 常量是指针？×
         - 所以不能用这个指针修改变量值，原来的声明可以修改值
         - const * 常量 指针
  
         ```cpp
         const int *p;
         int const *p;
         ```
  
       - 指针常量：
  
         - 指针是常量？√
         - 所以指针指向的东西不能改变：指向哪个变量就是哪个，不能修改
         - \* const 指针 常量
  
         ```cpp
         int *const p;
         ```
  
     - **8-2顶层const、底层const**
       - 顶层：修饰指针（指针常量）
       - 底层：修饰变量（常量指针）
       - 从右往左读变量声明，先修饰左边，左边没有修饰右边
  
  9. **const和#define区别**
  
     - 编译器处理方式不同：#define是预处理阶段展开；const是编译阶段使用
     - 类型和安全检查不同：#define没有类型，不做任何检查；const编译阶段会执行检查
     - 存储方式不同：#define代码展开，多个地方进行替换，不会分配内存；const分配内存，只维持一份拷贝
     - 定义域不同：#define不受定义域限制；const只在定义域内有效
  
  10. **typedef和define区别**
  
      |          | typedef                    | define                                                       |
      | -------- | -------------------------- | ------------------------------------------------------------ |
      | 用法     | 定义数据类型的别名         | 定义常量以及宏                                               |
      | 执行时间 | 编译时处理，有类型检查功能 | 预编译时期，不检查，只是替换，编译时候展开运行发生错误才报错 |
      | 作用域   | 有作用域限定               | 不受作用域约束，define声明后的引用都正确                     |
      | 指针     | typedef int*               |                                                              |
  
      - 指针相关
  
        ```cpp
        #define PTR1 int*
        PTR1 p1, p2;
        //p1是指针，p2不是指针
        
        typedef int* PTR2
        PTR2 p3, p4;
        //p3,p4都是指针
        ```
  
        
  
  11. **#ifdef、#else、#endif、#ifndef**
  
      - 条件编译：对一部分内容指定编译条件
  
      - ```cpp
        函数内部编译某些程序段
        #ifdef 条件
        	程序段
        #else
        	程序段
        #endif
        ```
  
      - 用if语句也能达到要求，但是编译了所有语句；条件编译可以减少被编译的语句
  
      - ```cpp
        避免头文件重定义
        #ifndef CLASSA_H
        #defind CLASSA_H
        ...
        #endif
        ```
  
  12. **volatile**
  
      - 表示变量随时可能被改变，编译后程序读取时候直接从地址读入，避免编译器优化从寄存器中读
      - 使用场景：
        - 多线程中被任务共享的变量
        - 中断服务程序中修改的供其他程序检测的变量
      - 一个参数可以既是const又是volatile吗？
        - 可以，表示程序内部只读不能改变（const），程序外部条件变化下改变且编译器不会优化这个变量（vilatile）
        - 原因：const不允许代码改变变量，但没有禁止某段内存的读写特性
  
  13. **sizeof、strlen的区别？**
  
      - |          | sizeof                       | strlen                     |
        | -------- | ---------------------------- | -------------------------- |
        | 类型     | 操作符                       | 库函数                     |
        | 参数     | 可以是数据类型，也可以是变量 | 字符串                     |
        | 计算时机 | 编译期间算出结果             | 运行时才算出结果           |
        | 数组为参 | 做sizeof参数不退化           | 传递给strlen就退化为指针了 |
  
  14. **strcpy、sprintf、memcpy的区别？**
  
      |          | strcpy             | sprintf                        | memcpy                                         |
      | -------- | ------------------ | ------------------------------ | ---------------------------------------------- |
      | 操作对象 | 两个对象均为字符串 | 源为多种数据类型，目的为字符串 | 两个对象为任意可操作的内存地址，不局限数据类型 |
      | 执行效率 | 中等               | 低                             | 最高                                           |
      | 功能     | 字符串直接拷贝     | 其他数据类型格式到字符串的转换 | 内存块的拷贝                                   |
  
  15. 
  
      - 

# C++面向对象

- Conception：
  1. 结构体
  1. 三大特征
  2. 访问权限public private protected
  3. struct和class
  4. 构造函数（默认构造函数、重载构造函数、拷贝构造函数、移动构造函数）
  5. this指针
  6. 成员初始化列表
  7. 拷贝构造函数、复制运算符
  8. 析构函数
  9. 初始化、复制
  10. 拷贝初始化、直接初始化
  11. 多态（继承+虚函数实现） 静态多台 动态多态
  12. 虚函数、纯虚函数、虚函数表、虚函数指针
  13. 继承 组合
  14. 覆盖、重载、重写、重定义（隐藏）
  15. 动态绑定 静态绑定
  16. 深拷贝、浅拷贝
  17. 友元函数、友元类
  18. 四个强制类型转换符（static_cast、dynamic_cast、const_cast、reinterpret_const、）
  19. final、override 
  20. RTTI
  1. 模板函数、模板类
- Question：
  1. **结构体？**
     - 声明时候可以直接初始化
     - 结构体可以直接赋值吗？：同一结构体的不同对象之间可以直接赋值，含有指针时候要小心（多个指针指向同一段内存，可能发生未知的内存释放）
  2. 

# C++内存管理

- Conception：
  1. 内存分区：堆栈全局常量代码区
  1. 堆和栈
  1. new/delete和malloc/free
  1. malloc、calloc、realloc
  1. 内存对齐
  1. 内存泄露
  1. 空类大小、类大小、对象大小
  1. 对象复用、零拷贝
- Question：
  1. 

# C++ STL

- Conception：
  1. 容器、算法、迭代器、空间配置器、仿函数、适配器
  1. vector
  1. list
  1. deque
  1. map、set、multimap、multiset
  1. unordered_map、unordered_set
  1. 迭代器：迭代器失效
- Question：
  1. 

# C++11

- Conception：
  1. 智能指针
  2. 右值引用、移动构造、完美转发
  3. nullptr
  4. Lambda表达式
  5. constexpr
  6. auto、decltype
  7. for()
  4. tuple
  
- Question：
  1. **智能指针？**
  
     - 智能指针是一个RAII模型（Resource Acquisition is Initialization，资源获取即初始化，构造函数分配内存，析构函数释放内存），用于动态分配内存；将基本类型指针封装为类对象指针，在离开作用域的时候调用析构函数，删除指针所指向的内存空间
     - 作用：出路内存泄露和空悬指针问题
     - auto_ptr：独占式拥有，同一时间只有一个智能指针可以指向该对象；C++11中抛弃；问题在于函数传参时，对象所有权不会返回，存在内存崩溃问题；不能指向数据，不能作为STL容器的成员
     - unique_ptr：独占式拥有，同一时间只有一个智能指针可以指向该对象；不能进行拷贝构造和拷贝赋值，可以进行移动构造和移动赋值
     - shared_ptr：共享式拥有，多个只能指针指向相同的对象；引用计数为0时释放对象；（同一**普通指针**不能同时为多个 shared_ptr 对象赋值，否则会导致程序发生异常）
     - weak_ptr：对对象的弱引用，不会增加对象的引用计数，搭配shared_ptr使用
  
  2. **右值引用、移动构造、完美转发**
  
     ```cpp
     右值引用（实现移动语义和完美转发，消除不必要的拷贝）：
     
     左值：等号左边，可以取地址
     右值：等号右边，不可以取地址
     
     左值引用&
     右值引用&&
     左值引用只能绑定左值，右值引用只能绑定右值
         
     //将左值转化为右值，给需要右值的地方把左值转化为右值传递右值
     std::move()
         
     
     引用折叠规则
     1.所有右值引用折叠到右值引用上仍然是一个右值引用。（A&& && 变成 A&&）
     2.所有的其他引用类型之间的折叠都将变成左值引用。 （A& & 变成 A&; A& && 变成 A&; A&& & 变成 A&）
     ```
  
     ```cpp
     移动语义（传递的是临时对象的话，原来的东西拷贝完就没用了，新的还得再申请释放）：
         
     //拷贝构造函数
     A(A& a)
     //移动构造函数
     A(A&& a)
     //拷贝赋值函数
     A& operator=(A& a)
     //移动赋值函数
     A& operator=(A&& a)
     ```
  
     - copy和move的区别![](https://upload-images.jianshu.io/upload_images/4427263-81a47fdc9b8d9e98.png?imageMogr2/auto-orient/strip|imageView2/2/w/264/format/webp)
  
     ```cpp
     完美转发（一个函数给另一个函数传参时候，原参数是左值/右值，新函数还能保持左值/右值，就是完美转发）：
     
     //不完美的转发
     void process(int& i){
         cout << "process(int&):" << i << endl;
     }
     void process(int&& i){
         cout << "process(int&&):" << i << endl;
     }
     
     void myforward(int&& i){
         cout << "myforward(int&&):" << i << endl;
         process(i);
     }
     int main(){
     	myforward(2);  //本来2是右值；到了myforward里有了名字i，再传递process时候变成了传递左值
     }
     
     
     //用来实现完美转发，forward可以实现左右值的相互转换，move只能左值到右值
     std::forward<T>(u)
     原则：a.T为左值引用时，u被转换为左值；b.否则u被转换为右值
         
     std::forward<int>(x) //x转换成右值，b
     std::forward<int &>(x) //x转换成左值，a
     std::forward<int &&>(x) //x转换成右值，b
     ```
  
     - 参考：[1知乎](https://zhuanlan.zhihu.com/p/335994370)、[2简书](https://www.jianshu.com/p/d19fc8447eaa)、[3CSDN](https://blog.csdn.net/zhangxiao93/article/details/74974546)

# 情景设计题

- Conception：
  1. 
  
- Question：
  1. 手写实现智能指针
  
     ```cpp
     //拷贝构造函数中计数初始化为1
     //拷贝构造函数计数值+1
     //赋值运算符左边-1，右边对象引用计数+1
     //析构函数引用计数-1，如果为0:delete释放对象
     ```
  
     
  
  2. 1