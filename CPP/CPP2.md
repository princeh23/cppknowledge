# 问题

- STL-22迭代器底层实现原理？

# 基础

- Conception：
  1. C和C++区别、和Java区别、和python区别
  1. 预处理、编译、汇编、链接
  2. 动态链接、静态链接
  3. 动态编译、静态编译
  4. 动态联编、静态联编
  5. 动态绑定、静态绑定
  5. 动态内存分配、静态内存分配
- Question：
  1. **C和C++有什么区别**？
     - C++是面向对象的语言，C是面向过程的语言
     - C++引入new/delete的概念，取代了C中malloc/free的概念
     - C++引入引用，C没有
     - C++引入类，C没有
     - C++引入函数重载，C没有
  2. C++和Python的区别？
  3. C++和Java的区别？
  4. **动态链接、静态链接？**
     - 动态链接：通过记录一系列符号和参数，程序运行时将信息传递给操作系统，操作系统将需要的动态库加载到内存中，运行时链接
       - 优点：共享一个动态库，节省资源
       - 缺点：运行时加载，影响性能
     - 静态链接：编译链接时直接将执行的代码拷贝到调用处
       - 优点：不用依赖库，可以独立执行
       - 缺点：体积大；静态库更新需要重新链接

# C++基础语法

- Conception：
  
  1. **定义相关**
  2. 声明、定义
  3. 全局变量、局部变量
  4. **指针相关**
  5. 指针、引用
  6. 指针、句柄
  7. 函数传递参数（形参、实参  值传递、指针传递、引用传递）
  8. 悬挂指针、野指针
  9. 指针常量、常量指针
  10. 指针数组、数组指针
  11. 函数指针
  12. **关键字相关**
  13. static
  14. #define 
  15. typedef
  16. const 指针常量、常量指针 顶层const、底层const
  17. volatile、mutable、explicit
  18. inline
  19. #ifdef、#else、#endif、#ifndef
  20. extern"C"
  21. **函数相关**
  22. sizeof、strlen
  23. strcpy、sprintf、memcpy
  24. **其他**
  18. 异常处理（try catch throw exception类）
  
- Question：

  1. **声明、定义？**

     - 声明：不分配地址；可以多个地方声明
     - 定义：分配地址和存储空间；只能定义一次
     - extern int  a：修饰的是变量的**声明**，此变量将在文件外/后面进行定义
  
  2. **全局变量和局部变量有什么区别？操作系统和编译器怎么知道？**
  
     - 全局变量：整个程序都可以访问；程序运行结束释放；存放在全局数据段
     - 局部变量：所在模块可以访问；函数调用完毕局部变量消失，内存释放；分配在堆栈
     - 操作系统和编译器根据内存分配位置判断
  
  3. **指针和引用？**
  
     |                                    | 指针                   | **引用**             |
     | ---------------------------------- | ---------------------- | -------------------- |
     |                                    | 拥有自己的空间         | 只是一个别名         |
     | sizeof大小                         | 4                      | 被引用对象的大小     |
     | 参数传递                           | 必须解引用才能操作对象 | 直接可以修改         |
     | **const**                          | **有const指针**        | **没有const引用**    |
     |                                    | 可以指向别的对象       | 不能被改变           |
     |                                    | 多级指针               | 只有一级             |
     | **返回动态内容分配的对象或者内存** | 必须用指针             | 引用可能引起内存泄露 |
  
  4. **指针和句柄？**
  
     - 指针：指向系统中物理内存的地址
     - 句柄：一种指向指针的指针，Windows用句柄标记系统资源，隐藏系统的信息
     
  4. **数组中a和&a有什么区别？**
  
     - ```cpp
       int a[10]; 
       int (*p)[10] = &a;
       
       a是数组名，也是数组元素首地址;
       a+1表示地址+1，表示a[1]的地址;
       *(a + 1) = a[1];
       
       &a是数组的指针，类型为int (*)[10]（数组指针）
       &a + 1表示数组首地址加上整个数组的偏移，表示a尾元素再下一个元素的地址
       ```
  
  6. **指针相关（常量指针/指针常量、悬挂指针/野指针、指针数组/数组指针、函数指针）**
  
     - **5-1常量指针和指针常量？**
  
       - 常量指针：
  
         - 常量是指针？×
         - 所以不能用这个指针修改变量值，原来的声明可以修改值
         - const * 常量 指针
  
         ```cpp
         const int *p;
         int const *p;
         ```
  
       - 指针常量：
  
         - 指针是常量？√
         - 所以指针指向的东西不能改变：指向哪个变量就是哪个，不能修改
         - \* const 指针 常量
  
         ```cpp
         int *const p;
         ```
  
     - **5-2悬挂指针和野指针？**
  
       - 悬挂指针：指针所指对象已经被释放
       - 野指针：未初始化的指针
       - 如何避免野指针？①初始化时指向NULL；②释放之后指向NULL；
  
     - **5-3数组指针、指针数组？**
  
       - http://c.biancheng.net/view/335.html
  
     - **5-4函数指针？**
  
       ```cpp
       //函数指针
       int (*fp)(int , int) = f;
       (*fp)(a, b);
           
       //返回值为指针
       int * fp(int , int)
       ```
       
       - ((void()())0)()什么含义？
         - void (\*)()：函数指针；无参数返回值为空*
         - ( void (*)() ) 0：把0强制转换成函数指针类型，一个函数存在首地址为0的一块区域内
         - ( void ()() ) 0：取0地址开始的一段内存中的内容，内容也就是函数的内容
         -  (void()()) 0 )()：函数调用
  
  6. **static关键字？**
  
     - 修饰局部变量：静态存储区分配内存；首次函数调用中初始化，之后的函数调用不再初始化；局部作用域内可见
     - 修饰全局变量：静态存储区分配内存；整个文件内可见，文件外不可见
     - 修饰函数：整个文件可以，文件外不可见；避免函数同名冲突
     - 修饰成员变量：所有对象共享；类外初始化；不需要对象实例化就可以访问
     - 修饰成员函数：所不能访问非静态成员（变量，不能调用非静态成员函数）原因是不能接受this指针，与任何对象无关；只能访问静态成员；不需要对象实例化就可以访问
     - C和C++中的区别：C只能修饰局部变量和全局变量、函数，C++还能修饰成员变量和成员函数
  
  7. **inline**
  
     - 优点
       - 调用地方展开，省去调用时间，提高效率
       - 相比#define宏函数，代码展开时会进行语法安全检查或数据类型转换，更加安全
     - 缺点
       - 代码膨胀，开销大
       - 如果内联函数本身执行时间长，效率提升小
       - 修改内联函数，所有调用内联函数的文件必须重新编译
     - 内联声明只是建议，是否内联由编译器决定，实际不可控
  
  8. **const**
  
     - **8-1常量指针、指针常量**
  
       - 常量指针：
  
         - 常量是指针？×
         - 所以不能用这个指针修改变量值，原来的声明可以修改值
         - const * 常量 指针
  
         ```cpp
         const int *p;
         int const *p;
         ```
  
       - 指针常量：
  
         - 指针是常量？√
         - 所以指针指向的东西不能改变：指向哪个变量就是哪个，不能修改
         - \* const 指针 常量
  
         ```cpp
         int *const p;
         ```
  
     - **8-2顶层const、底层const**
       - 顶层：修饰指针（指针常量），指向不可变，指向的变量内容可变
       - 底层：修饰变量（常量指针）
       - 从右往左读变量声明，先修饰左边，左边没有修饰右边
  
  9. **const和#define区别**
  
     - 编译器处理方式不同：#define是预处理阶段展开；const是编译阶段使用
     - 类型和安全检查不同：#define没有类型，不做任何检查；const编译阶段会执行检查
     - 存储方式不同：#define代码展开，多个地方进行替换，不会分配内存；const分配内存，只维持一份拷贝
     - 定义域不同：#define不受定义域限制；const只在定义域内有效
  
  10. **typedef和define区别**
  
      |          | typedef                    | define                                                       |
      | -------- | -------------------------- | ------------------------------------------------------------ |
      | 用法     | 定义数据类型的别名         | 定义常量以及宏                                               |
      | 执行时间 | 编译时处理，有类型检查功能 | 预编译时期，不检查，只是替换，编译时候展开运行发生错误才报错 |
      | 作用域   | 有作用域限定               | 不受作用域约束，define声明后的引用都正确                     |
      | 指针     | typedef int*               |                                                              |
  
      - 指针相关
  
        ```cpp
        #define PTR1 int*
        PTR1 p1, p2;
        //p1是指针，p2不是指针
        
        typedef int* PTR2
        PTR2 p3, p4;
        //p3,p4都是指针
        ```
  
  11. **#ifdef、#else、#endif、#ifndef**
  
      - 条件编译：对一部分内容指定编译条件
  
      - ```cpp
        函数内部编译某些程序段
        #ifdef 条件
        	程序段
        #else
        	程序段
        #endif
        ```
  
      - 用if语句也能达到要求，但是编译了所有语句；条件编译可以减少被编译的语句
  
      - ```cpp
        避免头文件重定义
        #ifndef CLASSA_H
        #defind CLASSA_H
        ...
        #endif
        ```
  
  12. **extern"C"**
  
      - 意义：指示编译器这部分代码按C语言（而不是C++）的方式进行编译，正确实现C++代码调用其他C语言代码
      - C不支持函数重载，编译函数时不会带上函数的参数类型，一般只包括函数名
      - C++支持函数重载，编译函数时会带上函数的参数类型
      - 使用场景：C++代码调用C语言代码；多个人协同开发
      
  12. **volatile**
  
      - 表示变量随时可能被改变，编译后程序读取时候直接从地址读入，避免编译器优化从寄存器中读
      - 使用场景：
        - 多线程中被任务共享的变量
        - 中断服务程序中修改的供其他程序检测的变量
      - 一个参数可以既是const又是volatile吗？
        - 可以，表示程序内部只读不能改变（const），程序外部条件变化下改变且编译器不会优化这个变量（vilatile）
        - 原因：const不允许代码改变变量，但没有禁止某段内存的读写特性
  
  13. **sizeof、strlen的区别？**
  
      - |          | sizeof                       | strlen                     |
        | -------- | ---------------------------- | -------------------------- |
        | 类型     | 操作符                       | 库函数                     |
        | 参数     | 可以是数据类型，也可以是变量 | 字符串                     |
        | 计算时机 | 编译期间算出结果             | 运行时才算出结果           |
        | 数组为参 | 做sizeof参数不退化           | 传递给strlen就退化为指针了 |
  
  14. **strcpy、sprintf、memcpy的区别？**
  
      |          | strcpy             | sprintf                        | memcpy                                         |
      | -------- | ------------------ | ------------------------------ | ---------------------------------------------- |
      | 操作对象 | 两个对象均为字符串 | 源为多种数据类型，目的为字符串 | 两个对象为任意可操作的内存地址，不局限数据类型 |
      | 执行效率 | 中等               | 低                             | 最高                                           |
      | 功能     | 字符串直接拷贝     | 其他数据类型格式到字符串的转换 | 内存块的拷贝                                   |
  
  15. 
  

# C++面向对象

- Conception：
  1. struct和class
  2. 访问权限public private protected
  3. 三大特征：封装、继承、多态
  4. 静态多态/静态绑定、动态多态/动态绑定
  5. 1
  6. 初始化、赋值
  7. 直接初始化、拷贝初始化
  8. 构造函数（默认构造函数、重载构造函数、拷贝构造函数、移动构造函数）
  9. 拷贝构造函数、赋值运算符
  10. this指针
  11. 成员初始化列表
  12. 
  13. 析构函数
  14. 
  15. 虚函数、纯虚函数、虚函数表、虚函数指针
  16. 
  17. 继承 组合
  18. 
  19. 重载、隐藏、重写/覆盖
  20. 
  21. 四个强制类型转换符（static_cast、dynamic_cast、const_cast、reinterpret_const）
  22. RTTI
  23. 
  24. 空类相关
  25. 
  26. 模板函数、模板类
  27. 模板函数、模板类的特例化
  28. 
  29. 深拷贝、浅拷贝
  30. 友元函数、友元类
  31. final、override 
  
- Question：
  1. **结构体？**
     - 声明时候可以直接初始化
     - 结构体可以直接赋值吗？：同一结构体的不同对象之间可以直接赋值，含有指针时候要小心（多个指针指向同一段内存，可能发生未知的内存释放）
  
  2. **C和C++的struct有什么不同？**
     - C不能有成员函数；C++可以有成员函数
     - C中没有private、public、protected访问限定符；C++中有
     - C中没有继承关系；C++中有继承关系
  
  3. **C++中struct和class的区别？**
     - struct默认public，class则默认private
  
     - struct默认public继承，class则默认private继承
  
     - class不用于定义模板参数，class还能用于定义模板参数
  
       ```cpp
       template<class T>
       template <typename T>
       ```
  
     - C++的struct定义必须保证C中struct的向下兼容性，所以类通常定义为class
  
  4. **面向对象三大特征？**
  
     - 封装：将客观事务封装成抽象的类；己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏
     - 继承：使用现有类的所有功能，无需重新编写即可实现功能的拓展
     - 多态：对不同对象发送同一个消息，不同对象会做出不同的响应
       - 函数重载、函数模板时候体现出来的多态
       - 调用成员函数时候，根据指针指向对象的类型执行不同的函数（基类指针/引用指向派生类对象）
  
  5. **多态的实现方式？**
  
     - 静态多态/静态绑定：编译期间确定；函数重载、函数模板
     - 动态多态/动态绑定：运行期间确定；虚函数+继承实现，基类指针/引用运行期间再决定使用哪个函数
  
  6. **动态多态/动态绑定作用？必要条件？如何实现？**
  
     - 作用：提高代码复用性；使基类指针/引用可以使用派生类功能，接口重用，向后兼容，提高可扩充性和可维护性
     - 必要条件：继承、**虚函数（virtual）**、基类指针/引用
     - 如何实现：含有虚函数的类，会创建一个虚函数表，对象中会有一个vptr指向虚函数表；基类指针指向派生类对象时候，vptr替换，就指向了派生类的虚函数表
  
  7. **访问权限？**
  
     - public、private、protected
     - 类内部均可相互访问
     - 类外部，只能访问public
  
  8. **初始化、赋值？**
  
     - ```cpp
       int a = 100;
       a = 100
       ```
  
  9. **直接初始化、拷贝/复制初始化？**
  
     - 直接初始化()：直接选择调用类的**各种构造函数**
  
     - 拷贝初始化=：先创建一个临时对象（允许跳过），再调用**各种拷贝构造函数**
  
     - ```cpp
       //直接初始化
       string a; //调用默认构造函数
       string a("hello"); //调用参数为const char *类型的构造函数
       string b(a); //调用拷贝构造函数
       
       //拷贝初始化
       string a="hello"; //先调用const char *类型的构造函数创建临时对象，然后调用拷贝构造函数
       string b=a; //a已经存在，直接调用拷贝构造函数
       ```
  
  10. **为什么基类的构造函数不能为定义为虚函数？**
  
      - 如果构造函数是虚函数，就必须通过vptr调用，但是对象还没有构造，没有vptr
      - 虚函数的意义在于通过父类指针调用子类成员函数，构造函数创建对象时候自动调用，不可能通过父类指针调用
  
  11. **构造函数能抛出异常吗？**
  
      - 可以抛出，但尽量不要，会造成内存泄露
  
  12. **拷贝构造函数、赋值运算符区别？**
  
      - 拷贝构造函数：构造**新**的对象
  
        ```cpp
        Student S;
        Student s1 = s;
        Student s2(s);
        ```
  
      - 赋值运算符：将源对象的内容拷贝到目标对象
  
        ```cpp
        Student s;
        Student s1;
        s1 = s;
        ```
  
  13. **虚函数**
  
      - 实际的虚函数放在代码段（.text）
      - 类的最开始部分有一个虚函数表的指针vptr，虚函数表中放每个虚函数的地址
  
  14. **纯虚函数？**
  
      - 作用：实现一个接口，起到规范的作用，想要继承这个类必须覆盖该函数
  
      - ```cpp
        virtual void f() = 0
        ```
  
  15. **虚函数表**
  
      - 虚函数表中存的是虚函数对应的地址，子类覆盖时虚函数地址会被替换
      - 该类的所有对象共享类的虚函数表，每个对象都必须保存一个指向虚函数表的vptr，vptr地址不同，但指向同一虚函数表
  
  16. **如何让一个类不能被实例化？**
  
      - 定义为抽象类（存在纯虚函数）
      - 构造函数声明为private
  
  17. **为什么基类的虚构函数需要定义为虚函数？**
  
      - 基类指针指向子类对象，对象销毁时，不定义为虚函数，只能销毁派生类中的部分数据；使得销毁时调用派生类的析构函数
  
  18. **析构函数能抛出异常吗？**
  
      - 不可以，异常点之后的释放操作没有被执行，造成了内存泄露
  
  19. **多继承存在的问题？如何消除多继承中的二义性？**
  
      -  增加程序复杂度，难维护，易出错
      -  继承中消除二义性方法：使用`::`；覆盖基类中的同名成员；
      -  多继承（从多个基类派生）中消除二义性方法：使用`::`；覆盖基类中的同名成员；使用虚继承，不同继承路径的同名成员只有一份拷贝
  
  20. **重载、隐藏、重写/覆盖**
  
      - | **重载**           | 隐藏                                                         | 重写/覆盖                                                  |
        | ------------------ | ------------------------------------------------------------ | ---------------------------------------------------------- |
        | 一个类中函数的重载 | 两个类中，**可以是也可以不是虚函数**，函数名相同，**参数返回值相同/不相同** | 两个类中，**必须是虚函数**，函数名相同、**参数返回值相同** |
      
      - 形成覆盖的两个函数一定形成隐藏，覆盖/重写是隐藏的特例
      
      - | 三者 | 作用域 | 有无virtual | 函数名 | 形参列表   | 返回值类型   |
        | ---- | ------ | ----------- | ------ | ---------- | ------------ |
        | 重载 | 相同   | 可有可无    | 相同   | 不同       | 可同可不同   |
        | 隐藏 | 不同   | 可有可无    | 相同   | 可同可不同 | 可同可不同   |
        | 重写 | 不同   | 有          | 相同   | 相同       | 相同（协变） |
  
  21. **强制类型转换符？**（竖着看）
  
      | static_cast                                    | dynamic_cast                                                 | const_cast：                                    | reinterpret_cast                                             | bad_cast异常                                                 |      |
      | ---------------------------------------------- | ------------------------------------------------------------ | ----------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
      | 通常用于**数值类型**、**向上**转换             | 通常用于**多态类型**转换；转换的类型中必须有virtual（RTTI 依赖于虚表） | **删除const、volatile**属性                     | 各种之间的转换                                               | dynamic_cast指针转换失败返回目标类型的nullptr；对于**引用**转换失败引发**bad_cast**异常 |      |
      | 向上转换安全，**向下转换不安全**（父类->子类） | 向上向下转换均可，向下时有类型检查功能                       |                                                 | 指针转换为任意指针；整数转换为指针/引用；指针/引用转换为整数 |                                                              |      |
      |                                                | 指向派生类的基类指针转换为派生类的指针或引用； Child *pchild = dynamic_cast<Child *>(pfather); | 删除的不是变量的特性，删除的是指针/引用的常量性 | 不安全                                                       |                                                              |      |
  
      - C的强制转换强大但不明确，不进行错误检查容易出错
      - [讲解](https://www.cnblogs.com/Allen-rg/p/6999360.html)
  
  22. **RTTI？**
  
      - Runtime Type Information：运行时类型识别
      - 功能由两个运算符实现：
        - typeid：返回对象的类型；允许在运行时确定对象的类型
        - dynamic_cast：运行时检测，实现基类指针/引用向派生类指针/引用的安全转换
  
  23. **sizeof一个空类的值为多少？**
  
      - 为1
      - 编译器需要区分这个空类的不同实例，分配一个字节，使得空类的不同实例拥有独一无二的地址
  
  24. **空类有哪些成员函数？**
  
      - 构造函数
      - 拷贝构造函数
      - 赋值运算符
      - 析构函数
      - 取址运算符 `class1 * operator & (){}`
      - 取址运算符 const `class1 * operator & () const {}`
  
  25. **模板函数、模板类的特例化**
  
      - 模板函数特例化：**必须**为所有模板参数提供实参
  
      ```cpp
      template<typename T> //模板函数
      int compare(const T &v1,const T &v2)
      {
          if(v1 > v2) return -1;
          if(v2 > v1) return 1;
          return 0;
      }
      //模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T
      template<> 
      int compare(const char* const &v1,const char* const &v2)
      {
          return strcmp(p1,p2);
      }
      ```
  
      - 类模板特例化：**不必**为所有模板参数提供实参
  
      ```cpp
      template<typename T>
      class Foo
      {
          void Bar();
          void Barst(T a)();
      };
      
      template<>
      class Foo
      {
          void Bar();
          void Barst(int a)();
      };
      ```
  
      - 特例化类中的部分成员
  
      ```cpp
      template<typename T>
      class Foo
      {
          void Bar();
          void Barst(T a)();
      };
      
      template<>
      void Foo<int>::Bar()
      {
          //进行int类型的特例化处理
          cout << "我是int型特例化" << endl;
      }
      ```
  
      - 总结：
        - 先声明模板，后面放特例化版本
        - 特例化不影响参数匹配，都是最佳原则匹配

# C++内存管理

- Conception：
  1. 内存分区：堆栈全局常量代码区
  1. 堆和栈
  1. new/delete和malloc/free
  1. malloc、calloc、realloc
  1. 内存对齐
  1. 内存泄露
  1. 空类大小、类大小、对象大小
  1. 对象复用、零拷贝
  
- Question：
  1. **C++的内存分区？**
  
     - 栈：编译器分配、清除；存放函数的参数值、局部变量的值
     - 堆：程序员分配，new分配的内存块，程序员不释放的话，程序结束可能由os释放；
     - 自由存储区
     - 全局数据区/静态存储区
     - 常量存储区
     - 代码区
  
  1. **new/delete和malloc/free？**
  
     - |                            | new/delete                                                   | malloc/free                    |
       | -------------------------- | ------------------------------------------------------------ | ------------------------------ |
       | 分配内存的位置             | 自由存储区（C++动态分配和释放的概念，自由存储区可以是堆、全局/静态，具体位置要看具体实现实现，默认是new） | 堆（C和操作系统的概念）        |
       |                            | operator new函数分配一块足够大的内存；调用构造函数传入初值；对象构造完成后，返回一个指向该对象的指针 | 分配内存                       |
       |                            | 调用析构函数；调用operator delete函数释放内存空间            | 释放内存                       |
       | 是否调用构造函数与析构函数 | 调用                                                         | 不调用                         |
       | 分配成功的返回值           | 完整类型指针                                                 | void*，需要强制转换            |
       | 分配失败的返回值           | bad_alloc异常                                                | 返回NULL                       |
       | 分配内存的大小             | 编译器计算                                                   | 指定大小                       |
       | 函数重载                   | 允许                                                         | 不允许（C中的库函数）          |
       | 是否可以相互**调用**       | operator new的实现可以基于malloc                             | malloc的实现不可以调用new      |
       | 已分配内存的扩张           | 不支持                                                       | 使用realloc函数重新分配        |
       | 分配内存时内存不足         | 可以指定处理函数或重新制定分配器（new_handler、set_new_handler） | 返回NULL，无法通过用户代码处理 |
  
     - [参考1](https://www.cnblogs.com/qg-whz/p/5140930.html)、[参考2](https://zhuanlan.zhihu.com/p/338489910)
  
  1. **delete和delete[]有什么区别？**
  
     - 先调用析构函数再释放内存
  
     - delete对单个对象调用析构函数，delete[]对每个对象逐个调用析构函数
     - 简单类型没有析构函数，delete/delete[]一样；类对象用delete，类对象数组用delete[]（否则第一个之后的对象都不调用析构函数）
     - new/delete、new[]/delete[] 要配套使用
  
  1. **malloc申请的内存是否可以使用delete，new申请的内存是否可以使用free？**
  
     - new/delete调用构造/析构函数，malloc/free不调用
  
     - 不提倡混搭
  
       
  
     - 简单类型可以搭配
  
     - malloc申请的本身没有构造函数，可以调用delete
  
     - new申请的类对象中会free会导致没有调用虚构函数，内存泄露
  
  1. **内存块太小导致new、malloc分配失败怎么办**？
  
     - malloc分配失败返回NULL，分配完需要判断是否是NULL，及时调用return
  
       
  
     - new默认抛出bad_alloc，可以用try...catch...代码块捕获异常
  
     - 还可以自定义函数处理分配不足问题（set_new_handler、new_handler）
  
     - ```cpp
       //set_new_handler、new_handler
       namespace std{
           typedef void (*new_handler)(); //函数指针
           std::new_handler set_new_handler( std::new_handler new_p ); //设置自定义的处理函数
       }
       
       //eg:
       void out_of_memory() {  
           std::cout<<"out of memory!"<<std::endl;  
           std::set_new_handler(NULL);  
       } 
       
       int main(){
           set_new_handler(out_of_memory);
           int *ptr = new int[100000000]
       }
       ```
  
     - new_handler如何设计？
  
       - 删除其他无用内存
       - 当前new_handler不能解决，设置另一个new_handler函数解决
       - 卸载new_handler（std::set_new_handler(NULL); ）
       - 抛出异常
       - abort()、exit()直接退出程序
  
     - [参考](https://www.jianshu.com/p/179f3006e20d)
  
  1. **内存泄露？**
  
     - 场景：
       - 没有调用free/delete释放内存
       - 类中存在**指针成员**，拷贝构造函数/赋值运算符没有合理处理，两个对象一个释放之后另一个再访问出错
       - 基类的构造函数没有设置成虚函数，指向派生类的基类指针析构时候没有释放派生类的成员
     - 定位排查：
       - Linux下可用valgrind、mtrace
  
  1. **内存的分配方式？**
  
     - 栈：局部变量、函数参数等；动态扩张收缩
     - 堆：new/delete操作的内存块，动态内存分配，程序员自行申请；动态扩张收缩
     - 自由存储区：malloc/free分配的内存块，和堆很类似
     - 全局/静态存储区：整个程序运行区间都存在的全局变量、局部变量
     - 常量存储区：存放常量，不可修改
  
  1. **堆栈区别？**
  
     - |              | 栈                       | 堆                           |
       | ------------ | ------------------------ | ---------------------------- |
       | 分配管理方式 | 编译器管理（动态、静态） | 程序员操作分配和释放（动态） |
       | 产生碎片不同 | 不存在碎片               | 频繁分配和释放会产生大量碎片 |
       | 生长方向     | 高地址向低地址，向下     | 低地址向高地址，向上         |
       | 申请大小限制 | 大小固定，超过会栈溢出   | 不连续的内存区域，大小不定   |
       | 效率         | 高                       | 机制复杂，低                 |
  
  1. **静态内存分配、动态内存分配？**
  
     - |           | 静态内存分配         | 动态内存分配       |
       | --------- | -------------------- | ------------------ |
       | 时期      | 编译期间，按计划分配 | 运行期间，按需分配 |
       | 位置      | 栈                   | 堆                 |
       | 管理员    | 编译器管理           | 程序员控制         |
       | 效率/问题 | 效率更高             | 会产生内存泄露     |
  
  1. **如何构造一个类，使其只能在堆/栈上分配内存？**
  
     - 只在栈上：new（分配内存、调用构造函数）会使其在堆上分配，**重载new、delete为private**
     - 只在堆上：编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，**析构函数声明为private**
  
  1. **浅拷贝、深拷贝？**
  
     - 浅：多一个指针指向同一块内存
     - 深：创建一个相同的对象
  
  1. **字节对齐、结构体对齐？**
  
     - 结构体对齐：按结构体中size最大的成员对齐
  
     - #pragma pack(n)：以n字节方式进行对齐
  
     - C++11：alignof可以计算出类型的对齐方式，alignas可以指定结构体的对齐方式
  
       ```cpp
       struct alignas(4) Info2 {
         uint8_t a;
         uint16_t b;
         uint8_t c;
       };
       
       std::cout << sizeof(Info2) << std::endl;   // 8  4 + 4
       std::cout << alignof(Info2) << std::endl;  // 4
       
       
       //若alignas小于自然对齐的最小单位，则被忽略
       //想使用单字节对齐的方式，使用alignas是无效的。应该使用#pragma pack(push,1)或者使用__attribute__((packed))
       ```

# C++ STL

- Conception：
  1. 容器、算法、迭代器、空间配置器、仿函数、适配器
  1. vector
  1. list
  1. deque
  1. map、set、multimap、multiset
  1. unordered_map、unordered_set
  1. 迭代器
  
- Question：
  1. **STL是什么？**
  
     - 容器、算法、迭代器、空间配置器、仿函数、适配器
     - 容器：数据的存放；序列式容器（vector、list、deque）、关联式容器（set、map）
     - 算法：排序复制等等
     - 迭代器：不暴露容器内部结构的情况下对容器的遍历
  
  2. **STL两级空间配置器/内存优化？**
  
     - 第一级配置器：大于128byte，使用malloc、free
     - 第二级配置器：小于等于128byte
  
       - ![这里写图片描述](https://img-blog.csdn.net/20180202151904819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Nzc3N1dXV1dTY2Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
     - 维护一个指针数组，管理的内存块都是8的倍数（8-128），每个指针指向一个链表
       - 若链表为空，使用refill函数调用chunk_alloc从内存池中取出一块内存（20*xxbytes），refill函数切分为20个内存块，并组织成链表
     - 内存池的分配/chunk_alloc()函数：
       
       - \>= 20：分配20个
         - \>=1 && \<=20：分配剩余个
       - ==0：
           - 先将剩余的一些内存分配给其他合适的链表；
         - 然后调用malloc分配所需内存的2倍；
           - malloc成功返回给refill；
         - malloc失败先去其他更大的链表搜寻可用内存块，添加到内存池（递归调用chunk_alloc），如果其他链表也被用完，转向第一级空间配置器。
  
  3. **容器有哪些？**
  
     - 序列式容器：
       - array、vector、deque、list、forward_list、string
     - 关联式容器：
       - map、set、multiset、multimap、unordered_map、unordered_set、unordered_multiset、unordered_multimap
     - 容器适配器：
       - stack、queue、priority_queue
  
  4. **vector底层原理？**
  
     - 一段连续的线性内存空间，有三个迭代器start、finish、end_of_storage
  
     - ```cpp
       //SGI中的三个迭代器
       _M_start; //起始字节位置
       _M_finish; //当前最后一个元素的末尾字节
       _M_end_of_storage; //占用内存空间的末尾字节
       ```
  
     - ![img](http://c.biancheng.net/uploads/allimg/191212/2-191212123P2Q5.gif)
     - 空间不够时，申请1.5/2倍空间，把原来的数据拷贝到新的内存空间，释放原来的内存空间
     - 删除时候只删除数据，不释放空间
  
  5. **vector中size和capacity区别？**
  
     - size：当前有多少元素（finsh - start）
     - capacity：当前存储空间能容纳多少元素（end_of_storage - start）
  
  6. **vector中reserve和resize区别？**
  
     - reserve：仅仅设置**capacity**这个参数
     - resize：容量变大，填充初始值；容量变小，不调整容量，只把前n个元素填充为初始值
  
  7. **vector中的元素可以是引用吗？**
  
     - 不可以
  
     - 引用**不支持一般意义上的赋值**操作
  
     - vector中元素的两个要求：元素必须能赋值；元素必须能复制
  
     - ```cpp
       int &b = a;
       
       b = c; //不支持
       ```
  
  8. **vector使迭代器失效的情况？**
  
     - erase()：插入位置之后的迭代器、指针、引用失效
  
     - insert()：
  
       - 插入引起扩容，**全部失效**
       - 没有引起扩容，**插入位置之后的迭代器失效**
  
     - 扩容：其他地方开辟新一块内存，原迭代器全部失效
  
       
  
     - erase()可以返回下一个有效的iterator
  
     - ```cpp
       it=q.erase(it);
       ```
  
  9. **vector1.5/2倍扩容原因？**
  
     -  VS 下是 1.5倍，在 GCC 下是 2 倍
     -  为什么不能太小/为什么不是等长而是倍数增长：
       - 等长时，扩容次数多
       - 倍数时，效率更高，O(n)->O(1)
     -  为什么不能太大/为什么不是3、4倍：
       - 理想情况是扩容时候能复用之前释放的空间（1、1.5、2.25、3.375时候能复用前面的空间）
     -  win下1.5倍，linux下2倍？
        - win下会对释放的内存进行合并，1.5倍为了更好复用
        - linux下伙伴系统（将整个内存区域构建成基本大小basicSize的1倍、2倍、4倍...即要求内存空间分区链均对应2的整次幂倍大小的空间）管理空闲分区，2倍更合适
  
  10. **vector如何释放空间？**
  
      - vector删除元素内存不释放，析构时候才全部释放，clear()也是清空但不删除
  
      - 空间动态缩小，考虑deque
  
      - 使用swap
  
        ```cpp
        vector(Vec).swap(Vec); //将Vec的内存清除；
        
        vector().swap(Vec); //清空Vec的内存；
        ```
  
  11. **为什么vector的插入操作可能导致迭代器失效？**
  
      - 如果超过容量，2倍扩容是开辟新的内存再拷贝过去，原来的空间释放，迭代器失效
  
  12. **频繁的push_back()对vector性能的影响？**
  
      - 可能影响内存的重新分配，每次都需要开辟新的内存再拷贝过去，释放原来的空间
  
  13. **list的底层实现原理？**
  
      - 带头节点的双向循环链表
      - ![img](http://c.biancheng.net/uploads/allimg/191218/2-19121Q6445Q07.gif)
  
  14. **deque的底层实现原理？**
  
      - deque由一个map数组组成
  
      - 每个map指向一段连续的空间
  
      - 每段连续空间拥有一个迭代器
  
      - 一个迭代器由4个元素组成，cur、first、last、node
  
        
  
      - ++、--操作需要判断是否到了缓冲区头/尾
  
      - ![deque容器的底层实现](http://c.biancheng.net/uploads/allimg/191213/2-19121316430U40.gif)
  
      - 一些设计特点：
  
        - deque的start迭代器和finish迭代器并不是一开始就指向map数组的头尾，指向map的中间节点，为了使前后插入留有的空间相同
        - 插入、删除操作为了提高效率，会判断元素偏前还是偏后，偏前移动前面的元素
  
  15. **vector、list、deque适用场景？**
  
      - vector：需要随机存取，不关心插入删除
      - list：需要插入删除，不关心随机存取（写多读少的场景）
      - deque：需要随机存取、头尾的随机存取
  
  16. **map、set、multiset、multimap底层原理？**
  
      - 红黑树
      - 特点：
        - 节点不是黑就是红
        - 根节点是黑色的
        - 叶子节点都是空节点null、并且是黑色的
        - 红色节点的两个子节点都是黑色节点
        - 从任意节点到叶子节点的路径都包括相同数量的黑色节点（黑子节点的数量称为**黑高**）
      - 从根节点到叶子节点的最长路径不大于最短路径的 2 倍：最短路径是全黑色节点，最长路径（有红色节点必有黑色节点，红黑色节点数量相同时候，长度=黑色或红色 * 2）
      - 增删改查速度为logn
  
  17. **为何map和set的插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效？**
  
      - 存储的是节点，不需要内存拷贝和内存移动
      - 插入操作只是指针换来换区，节点内存没有改变
  
  18. **map的插入方式？**
  
      - ```cpp
        //关键字存在插入失败，不会报错，但数据插入不了
        m.insert(PII(1, 1));
        m.insert(map<int,int>::value_type(1, 1)); //插入value_type数据
        m.insert(make_pair(1, 1));
        
        //关键字存在也可以插入，直接覆盖
        m[1] = 1;
        ```
  
  19. **map中find和[]的区别？**
  
      - []：找到key返回这个值；没找到key插入value
      - find()：找到返回该位置迭代器；没找到返回尾迭代器
  
  20. **map和vector中[]的区别？**
  
      - vector中[]会做边界检查
      - map中[]找到返回，没找到插入
  
  21. **unordered_map、unordered_set、unordered_multimap、unordered_multiset底层原理？**
  
      - unordered\_和hash\_的本质一样，只不过unordered\_被纳入标准
      - 底层用哈希表，用一个vector数组存储哈希值，并且使用拉链法、链表解决冲突
      - ![C++ STL 无序容器存储状态示意图](http://c.biancheng.net/uploads/allimg/200221/1-200221131A4220.gif)
      - vector大小为质数，57、97、193...（28个质数），超过大小新开一个vector，交换两个vector，释放临时vector
      - 每个**链表**称为一个**桶**
      - 总键值对数/桶数=负载因子，负载因子如果超过默认值，自动增加桶数，重新哈希 
  
  22. 迭代器底层实现原理？
  
      - 迭代器是连接容器和算法的桥梁，在不了解容器内部原理的情况下遍历容器
  
      - 迭代器相当于一个智能指针
  
        
  
      - 
  
      - https://www.1024sou.com/article/116231.html
  
  23. **迭代器的型别？**
  
      - 迭代器的相应型别：迭代器所指之物的类型（特性）
      - value_type：迭代器所指对象类型（T）
      - difference_type：两个迭代器之间的距离
      - reference_type：迭代器所指对象类型的引用（T&）
      - pointer_type：迭代器所指对象类型的指针（*T）
      - iterator_categoty：迭代器种类类型
  
  24. **迭代器的种类？**
  
      - input_iterator：只读，从一个对象中读出元素（==、!=、->、*）
      - output_iterator：只写，向一个对象中修改/添加（*i = v，++）
      - forward_iterator：读写、单向移动，一次一步（++）
      - bidirectional_iterator：读写、双向移动，一次一步（--）
      - random access iterator：所有操作，任意读写，还另外支持[i]
      - ![img](https://images.cnblogs.com/cnblogs_com/xkfz007/201210/201210102213047928.png)
  
  25. **各种容器删除一个元素？**
  
      - 顺序容器：迭代器之后的容器失效（list除外），erase返回值是下一个有效迭代器
  
        ```cpp
        it = c.erase(it);
        ```
  
      - 关联容器：被删除元素的迭代器失效，返回值是void
  
        ```cpp
        c.erase(it++);
        ```
  
  26. **迭代器失效？**
  
      - 插入：vector、deque插入之后的位置失效，list、forward_list、map、set插入操作不失效
      - 删除：vector、deque删除之后的位置失效，list、forward_list、map、set仅删除位置失效；递增当前iterator即可获取下一个位置
      - 扩容：内存重新分配全部失效
      - unordered_迭代器意义不大，stack、queue、priority_queue没有迭代器
      - [掘金总结](https://juejin.cn/post/6971252856498159653)
  
  27. 容器适配器？
  
      - 
  
  28. **如何在共享内存上使用STL？**
  
      - [讲解](https://blog.51cto.com/u_15127614/3384436)

# C++11

- Conception：
  1. 智能指针
  2. 右值引用、移动构造、完美转发
  3. nullptr
  4. Lambda表达式
  5. constexpr
  6. auto、decltype
  7. for()
  4. tuple
  
- Question：
  1. **智能指针？**
  
     - 智能指针是一个RAII模型（Resource Acquisition is Initialization，资源获取即初始化，构造函数分配内存，析构函数释放内存），用于动态分配内存；将基本类型指针封装为类对象指针，在离开作用域的时候调用析构函数，删除指针所指向的内存空间
  
     - 作用：出路内存泄露和空悬指针问题
  
     - auto_ptr（C++98）：独占式拥有，同一时间只有一个智能指针可以指向该对象；C++11中抛弃；问题在于函数传参时，对象所有权不会返回，存在**内存崩溃问题**；不能指向数据，不能作为STL容器的成员
  
       ```cpp
       auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
       auto_ptr<string> p2;
       p2 = p1; //不会报错.
                                         
       //p2剥夺了p1所有权，再访问p1会报错
       ```
  
     - unique_ptr：独占式拥有，同一时间只有一个智能指针可以指向该对象；不能进行拷贝构造和拷贝赋值，可以进行移动构造和移动赋值
  
       ```cpp
       auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
       auto_ptr<string> p2;
       p2 = p1; //会报错.
       p2 = unique_ptr<string>(new string ("You"));   // 临时对象不会报错
                                                                        
       unique_ptr<string> ps1, ps2;
       ps1 = demo("hello");
       ps2 = move(ps1); //实现了所有权的转移
       ps1 = demo("alexia");
       cout << *ps2 << *ps1 << endl;                                  
       ```
  
     - shared_ptr：共享式拥有，多个只能指针指向相同的对象；引用计数为0时释放对象；（同一**普通指针**不能同时为多个 shared_ptr 对象赋值，否则会导致程序发生异常）
  
     - weak_ptr：对对象的弱引用，不会增加对象的引用计数，搭配shared_ptr使用；只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造；解决shared_ptr**相互引用**时的死锁问题（两个shared_ptr相互引用，两个指针的引用计数永远不可能下降为0，资源永远不会释放）
  
  2. **右值引用、移动构造、完美转发**
  
     ```cpp
     右值引用（实现移动语义和完美转发，消除不必要的拷贝）：
     
     左值：等号左边，可以取地址
     右值：等号右边，不可以取地址
     
     左值引用&
     右值引用&&
     左值引用只能绑定左值，右值引用只能绑定右值
         
     //将左值转化为右值，给需要右值的地方把左值转化为右值传递右值
     std::move()
         
     
     引用折叠规则
     1.所有右值引用折叠到右值引用上仍然是一个右值引用。（A&& && 变成 A&&）
     2.所有的其他引用类型之间的折叠都将变成左值引用。 （A& & 变成 A&; A& && 变成 A&; A&& & 变成 A&）
     ```
  
     ```cpp
     移动语义（传递的是临时对象的话，原来的东西拷贝完就没用了，新的还得再申请释放）：
         
     //拷贝构造函数
     A(A& a)
     //移动构造函数
     A(A&& a)
     //拷贝赋值函数
     A& operator=(A& a)
     //移动赋值函数
     A& operator=(A&& a)
     ```
  
     - copy和move的区别![](https://upload-images.jianshu.io/upload_images/4427263-81a47fdc9b8d9e98.png?imageMogr2/auto-orient/strip|imageView2/2/w/264/format/webp)
  
     ```cpp
     完美转发（一个函数给另一个函数传参时候，原参数是左值/右值，新函数还能保持左值/右值，就是完美转发）：
     
     //不完美的转发
     void process(int& i){
         cout << "process(int&):" << i << endl;
     }
     void process(int&& i){
         cout << "process(int&&):" << i << endl;
     }
     
     void myforward(int&& i){
         cout << "myforward(int&&):" << i << endl;
         process(i);
     }
     int main(){
     	myforward(2);  //本来2是右值；到了myforward里有了名字i，再传递process时候变成了传递左值
     }
     
     
     //用来实现完美转发，forward可以实现左右值的相互转换，move只能左值到右值
     std::forward<T>(u)
     原则：a.T为左值引用时，u被转换为左值；b.否则u被转换为右值
         
     std::forward<int>(x) //x转换成右值，b
     std::forward<int &>(x) //x转换成左值，a
     std::forward<int &&>(x) //x转换成右值，b
     ```
  
     - 参考：[1知乎](https://zhuanlan.zhihu.com/p/335994370)、[2简书](https://www.jianshu.com/p/d19fc8447eaa)、[3CSDN](https://blog.csdn.net/zhangxiao93/article/details/74974546)

# 情景设计题

- Conception：
  1. 
  
- Question：
  1. **设置地址为为0x67a9 的整型变量的值为0xaa66？**
  
     ```cpp
     int *ptr;
     ptr = (int *)0x67a9;
     *ptr = 0xaa66;
     ```
     
  1. 手写实现智能指针
  
     ```cpp
     //拷贝构造函数中计数初始化为1
     //拷贝构造函数计数值+1
     //赋值运算符左边-1，右边对象引用计数+1
     //析构函数引用计数-1，如果为0:delete释放对象
     ```
  
     
  
  2. 1