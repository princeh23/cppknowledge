# 基础

- Conception：
  1. C和C++区别、和Java区别、和python区别
  1. 预处理、编译、汇编、链接
  2. 动态链接、静态链接
  3. 动态编译、静态编译
  4. 动态联编、静态联编
  5. 动态绑定、静态绑定
- Question：
  1. **C和C++有什么区别**？
     - C++是面向对象的语言，C是面向过程的语言
     - C++引入new/delete的概念，取代了C中malloc/free的概念
     - C++引入引用，C没有
     - C++引入类，C没有
     - C++引入函数重载，C没有
  2. C++和Python的区别？
  3. C++和Java的区别？
  4. **动态链接、静态链接？**
     - 动态链接：通过记录一系列符号和参数，程序运行时将信息传递给操作系统，操作系统将需要的动态库加载到内存中，运行时链接
       - 优点：共享一个动态库，节省资源
       - 缺点：运行时加载，影响性能
     - 静态链接：编译链接时直接将执行的代码拷贝到调用处
       - 优点：不用依赖库，可以独立执行
       - 缺点：体积大；静态库更新需要重新链接

# C++基础语法

- Conception：
  
  1. **定义相关**
  1. 声明、定义
  1. **指针相关**
  2. 指针、引用
  3. 函数传递参数（形参、实参  值传递、指针传递、引用传递）
  4. 指针常量、常量指针
  5. 指针数组、数组指针
  6. 悬挂指针、野指针
  7. 函数指针
  7. **关键字相关**
  8. static
  9. #define 
  10. typedef
  11. const 指针常量、常量指针 顶层const、底层const
  12. volatile、mutable、explicit
  13. inline
  14. #ifdef、#else、#endif、#ifndef
  14. **函数相关**
  15. sizeof、strlen
  16. strcpy、sprintf、memcpy
  16. **其他**
  17. extern"C"
  18. 异常处理（try catch throw exception类）
  
- Question：

  1. **声明、定义？**

     - 声明：不分配地址；可以多个地方声明
     - 定义：分配地址和存储空间；只能定义一次
     - extern int  a：修饰的是变量的**声明**，此变量将在文件外/后面进行定义
  
  2. **数组中a和&a有什么区别？**
  
     - ```cpp
       int a[10]; 
       int (*p)[10] = &a;
       
       a是数组名，也是数组元素首地址;
       a+1表示地址+1，表示a[1]的地址;
       *(a + 1) = a[1];
       
       &a是数组的指针，类型为int (*)[10]（数组指针）
       &a + 1表示数组首地址加上整个数组的偏移，表示a尾元素再下一个元素的地址
       ```

  3. 悬挂指针和野指针？

     - 悬挂指针：指针所指对象已经被释放
     - 野指针：未初始化的指针
  
  4. 数组指针、指针数组？
  
     - http://c.biancheng.net/view/335.html
  
  5. **static关键字？**
  
     - 修饰局部变量：静态存储区分配内存；首次函数调用中初始化，之后的函数调用不再初始化；局部作用域内可见
     - 修饰全局变量：静态存储区分配内存；整个文件内可见，文件外不可见
     - 修饰函数：整个文件可以，文件外不可见；避免函数同名冲突
     - 修饰成员变量：所有对象共享；类外初始化；不需要对象实例化就可以访问
     - 修饰成员函数：不能接受this指针，只能访问静态成员；不需要对象实例化就可以访问
     - C和C++中的区别：C只能修饰局部变量和全局变量、函数，C++还能修饰成员变量和成员函数
  
  6. **inline**
  
     - 优点
       - 调用地方展开，省去调用时间，提高效率
       - 相比#define宏函数，代码展开时会进行语法安全检查或数据类型转换，更加安全
     - 缺点
       - 代码膨胀，开销大
       - 如果内联函数本身执行时间长，效率提升小
       - 修改内联函数，所有调用内联函数的文件必须重新编译
     - 内联声明只是建议，是否内联由编译器决定，实际不可控
  
  7. **const和#define区别**
  
     - 编译器处理方式不同：#define是预处理阶段展开；const是编译阶段使用
     - 类型和安全检查不同：#define没有类型，不做任何检查；const编译阶段会执行检查
     - 存储方式不同：#define代码展开，多个地方进行替换，不会分配内存；const分配内存，只维持一份拷贝
     - 定义域不同：#define不受定义域限制；const只在定义域内有效
  
  8. **#ifdef、#else、#endif、#ifndef**
  
     - 条件编译：对一部分内容指定编译条件
  
     - ```cpp
       函数内部编译某些程序段
       #ifdef 条件
       	程序段
       #else
       	程序段
       #endif
       ```
  
     - 用if语句也能达到要求，但是编译了所有语句；条件编译可以减少被编译的语句
  
     - ```cpp
       避免头文件重定义
       #ifndef CLASSA_H
       #defind CLASSA_H
       ...
       #endif
       ```
  
  9. **sizeof、strlen的区别？**
  
     - |          | sizeof                       | strlen                     |
       | -------- | ---------------------------- | -------------------------- |
       | 类型     | 操作符                       | 库函数                     |
       | 参数     | 可以是数据类型，也可以是变量 | 字符串                     |
       | 计算时机 | 编译期间算出结果             | 运行时才算出结果           |
       | 数组为参 | 做sizeof参数不退化           | 传递给strlen就退化为指针了 |
  
  10. 

# C++面向对象

- Conception：
  1. 结构体
  1. 三大特征
  2. 访问权限public private protected
  3. struct和class
  4. 构造函数（默认构造函数、重载构造函数、拷贝构造函数、移动构造函数）
  5. this指针
  6. 成员初始化列表
  7. 拷贝构造函数、复制运算符
  8. 析构函数
  9. 初始化、复制
  10. 拷贝初始化、直接初始化
  11. 多态（继承+虚函数实现） 静态多台 动态多态
  12. 虚函数、纯虚函数、虚函数表、虚函数指针
  13. 继承 组合
  14. 覆盖、重载、重写、重定义（隐藏）
  15. 动态绑定 静态绑定
  16. 深拷贝、浅拷贝
  17. 友元函数、友元类
  18. 四个强制类型转换符（static_cast、dynamic_cast、const_cast、reinterpret_const、）
  19. final、override 
  20. RTTI
  1. 模板函数、模板类
- Question：
  1. **结构体？**
     - 声明时候可以直接初始化
     - 结构体可以直接赋值吗？：同一结构体的不同对象之间可以直接赋值，含有指针时候要小心（多个指针指向同一段内存，可能发生未知的内存释放）
  2. 

# C++内存管理

- Conception：
  1. 内存分区：堆栈全局常量代码区
  1. 堆和栈
  1. new/delete和malloc/free
  1. malloc、calloc、realloc
  1. 内存对齐
  1. 内存泄露
  1. 空类大小、类大小、对象大小
  1. 对象复用、零拷贝
- Question：
  1. 

# C++ STL

- Conception：
  1. 容器、算法、迭代器、空间配置器、仿函数、适配器
  1. vector
  1. list
  1. deque
  1. map、set、multimap、multiset
  1. unordered_map、unordered_set
  1. 迭代器：迭代器失效
- Question：
  1. 

# C++11

- Conception：
  1. 智能指针
  2. 右值引用、移动构造、完美转发
  3. nullptr
  4. Lambda表达式
  5. constexpr
  6. auto、decltype
  7. for()
  4. tuple
  
- Question：
  1. **智能指针？**
  
     - 智能指针是一个RAII模型（Resource Acquisition is Initialization，资源获取即初始化，构造函数分配内存，析构函数释放内存），用于动态分配内存；将基本类型指针封装为类对象指针，在离开作用域的时候调用析构函数，删除指针所指向的内存空间
     - 作用：出路内存泄露和空悬指针问题
     - auto_ptr：独占式拥有，同一时间只有一个智能指针可以指向该对象；C++11中抛弃；问题在于函数传参时，对象所有权不会返回，存在内存崩溃问题；不能指向数据，不能作为STL容器的成员
     - unique_ptr：独占式拥有，同一时间只有一个智能指针可以指向该对象；不能进行拷贝构造和拷贝赋值，可以进行移动构造和移动赋值
     - shared_ptr：共享式拥有，多个只能指针指向相同的对象；引用计数为0时释放对象；（同一**普通指针**不能同时为多个 shared_ptr 对象赋值，否则会导致程序发生异常）
     - weak_ptr：对对象的弱引用，不会增加对象的引用计数，搭配shared_ptr使用
  
  2. **右值引用、移动构造、完美转发**
  
     ```cpp
     右值引用（实现移动语义和完美转发，消除不必要的拷贝）：
     
     左值：等号左边，可以取地址
     右值：等号右边，不可以取地址
     
     左值引用&
     右值引用&&
     左值引用只能绑定左值，右值引用只能绑定右值
         
     //将左值转化为右值，给需要右值的地方把左值转化为右值传递右值
     std::move()
         
     
     引用折叠规则
     1.所有右值引用折叠到右值引用上仍然是一个右值引用。（A&& && 变成 A&&）
     2.所有的其他引用类型之间的折叠都将变成左值引用。 （A& & 变成 A&; A& && 变成 A&; A&& & 变成 A&）
     ```
  
     ```cpp
     移动语义（传递的是临时对象的话，原来的东西拷贝完就没用了，新的还得再申请释放）：
         
     //拷贝构造函数
     A(A& a)
     //移动构造函数
     A(A&& a)
     //拷贝赋值函数
     A& operator=(A& a)
     //移动赋值函数
     A& operator=(A&& a)
     ```
  
     - copy和move的区别![](https://upload-images.jianshu.io/upload_images/4427263-81a47fdc9b8d9e98.png?imageMogr2/auto-orient/strip|imageView2/2/w/264/format/webp)
  
     ```cpp
     完美转发（一个函数给另一个函数传参时候，原参数是左值/右值，新函数还能保持左值/右值，就是完美转发）：
     
     //不完美的转发
     void process(int& i){
         cout << "process(int&):" << i << endl;
     }
     void process(int&& i){
         cout << "process(int&&):" << i << endl;
     }
     
     void myforward(int&& i){
         cout << "myforward(int&&):" << i << endl;
         process(i);
     }
     int main(){
     	myforward(2);  //本来2是右值；到了myforward里有了名字i，再传递process时候变成了传递左值
     }
     
     
     //用来实现完美转发，forward可以实现左右值的相互转换，move只能左值到右值
     std::forward<T>(u)
     原则：a.T为左值引用时，u被转换为左值；b.否则u被转换为右值
         
     std::forward<int>(x) //x转换成右值，b
     std::forward<int &>(x) //x转换成左值，a
     std::forward<int &&>(x) //x转换成右值，b
     ```
  
     - 参考：[1知乎](https://zhuanlan.zhihu.com/p/335994370)、[2简书](https://www.jianshu.com/p/d19fc8447eaa)、[3CSDN](https://blog.csdn.net/zhangxiao93/article/details/74974546)

# 情景设计题

- Conception：
  1. 
  
- Question：
  1. 手写实现智能指针
  
     ```cpp
     //拷贝构造函数中计数初始化为1
     //拷贝构造函数计数值+1
     //赋值运算符左边-1，右边对象引用计数+1
     //析构函数引用计数-1，如果为0:delete释放对象
     ```
  
     
  
  2. 1