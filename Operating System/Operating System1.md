# 基本概念

- Conception：
  1. 并发、并行
  1. 同步、异步、阻塞、非阻塞
  1. 同步、互斥
  1. 用户态、内核态
  1. 外中断、异常
  
- Question：

  1. **并行，并发？**

     - | 并行           | 并发               |
       | -------------- | ------------------ |
       | 一起进行       | 一起发生           |
       | 几个同时进行   | 几个间隔进行       |
       | 边吃饭边打电话 | 吃饭、打电话、吃饭 |

  2. **同步、异步、阻塞、非阻塞**

     - 同步和异步关注的是消息通信机制
     - 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态
     - 同步：调用发出后，等待结果
     - 异步：调用发出后，等待处理完通知
     - 阻塞：调用结果返回前，挂起线程
     - 非阻塞：调用结果返回前，不阻塞线程
  
  3. **同步、互斥？**
  
     - 互斥：通过竞争对资源的独占使用；彼此之间不需要知道对方的存在；执行顺序是一个乱序
     - 同步：协调多个相互关联线程合作完成任务；彼此之间知道对方存在；执行顺序往往是有序的
  
  4. **用户态、内核态？**
  
     - | 内核态                 | 用户态                |
       | ---------------------- | --------------------- |
       | 运行操作程序、操作硬件 | 运行用户程序          |
       | CPU可以访问任意的数据  | CPU只能受限的访问内存 |
  
     - 进程由内核管理调度、进程的切换只能发生在内核态
  
  5. 用户态和内核态如何切换？
  
     - 用户态->内核态：系统调用、异常、设备的中断信号
     
  5. **外中断、异常？**
  
     - 外中断：CPU执行指令的外部事件引起（输入输出、时钟中断）
     - 异常：CPU执行指令的内部事件引起（地址越界、溢出）

# 预编译->编译->汇编->链接

- Conception：

  1. 预编译、编译、汇编、链接
  2. 静态链接、动态链接
  3. 静态链接库、动态链接库

- Question：

  1. **一个程序从开始到结束的完整过程？**

     - 预编译：主要处理#的内容
     - 编译：词法分析、语法分析、语义分析 x.c->x.i
     - 汇编：汇编指令翻译成机器指令 x.i->x.o
     - 链接：将目标文件进行链接，形成可执行程序 x.o->可执行

  2. **静态链接、动态链接？**

     - | 静态链接                     | 动态链接                                                     |
       | ---------------------------- | ------------------------------------------------------------ |
       | 编译链接时将代码拷贝到调用处 | 不直接拷贝代码，需要的时候加载到内存，多个程序调用一个时候可以共享内存 |
       | 运行速度快                   | 多个程序共享一段代码                                         |
       | 浪费空间、更新困难           | 运行时加载、速度慢：                                         |

  3. 

# 进程管理

- Conception：
  1. 程序
  2. 进程：运行着的程序
  3. 线程：进程当中的一条执行流程
  4. 协程
  5. 进程间通信
  6. 进程调度算法
  7. 读写锁、互斥锁、条件变量、自旋锁
  7. 守护进程、僵尸进程、孤儿进程
  8. 生产者-消费者问题、哲学家问题、读者-写者问题
  
- Question：

  1. **程序和进程的区别？**

     | 程序   | 进程                 |
     | ------ | -------------------- |
     | 静态   | 动态                 |
     | 永久的 | 暂时存在的           |
     |        | 进程是程序的一次执行 |

  2. 进程、线程、协程区别？

     |            | 进程                     | 线程                                  | 协程     |
     | ---------- | ------------------------ | ------------------------------------- | -------- |
     | 单位       | 资源分配的最小单位       | CPU调度的最小单位，程序执行的基本单位 |          |
     |            | 不同进程地址空间相互独立 | 同一进程的线程共享同一地址空间        |          |
     | 上下文切换 |                          |                                       |          |
     | 系统开销   |                          | 只切换少量寄存器内容，开销小          |          |
     | 机制       | 同步机制                 | 同步机制                              | 异步机制 |
  
  3. **为什么要有进程？**
  
     - 单道批处理中CPU效率高，IO低速，cpu要等待；多道批处理，存在共享资源导致程序相互限制
     - 进程实现了多个程序并发执行
  
  4. **为什么要有线程？**
  
     - 进程切换系统开销大，线程切换仅需保存和设置少量寄存器内容，适合高并发环境
  
  5. **进程状态切换？**
  
     - 三状态、五状态、七状态
     - 创建态
     - 就绪态、运行态、阻塞态
     - 终止态
     - 挂起态
     - ![img](https://img2020.cnblogs.com/blog/2035133/202005/2035133-20200522164338324-1491135241.png)
     - 就绪->运行：根据调度算法选择进入
     - 运行->就绪：时间片用完
     - 运行->阻塞：发生等待事件进入阻塞
     - 阻塞->就绪：等待的事件已经发生
     - ![img](https://img2020.cnblogs.com/blog/2035133/202005/2035133-20200522165512933-851446445.png)
  
  6. **进程间通信？**
  
     - 进程的用户地址独立，不能互相访问，内核空间是共享的，进程之间通信必须通过内核
  
     - |               |                                                              | 缺点                             |
       | ------------- | ------------------------------------------------------------ | -------------------------------- |
       | 管道/匿名管道 | 管道（内核里面的一串缓存）；单向、半双工；只能在存在父子关系的进程 | 效率低                           |
       | 有名管道      | 半双工；不相关的进程间也能相互通信                           |                                  |
       | 共享内存      | 不同进程拿出自己的一段地址空间，映射到相同的物理内存         | 同时修改，存在冲突               |
       | 消息队列      | 消息链表                                                     | 附件有大小限制、不适合大数据传输 |
       | 信号量        | 一个整型计数器，实现进程间互斥和同步，P（-）V（+）操作       |                                  |
       | 信号          | 通知某个事件已经发生；唯一的异步通信机制                     |                                  |
       | 套接字        | 不同主机上的进程间的通信                                     |                                  |
  
  7. **进程的调度算法？**
  
     - 先来先服务：先来的先
     - 短作业优先：短的先
     - 时间片轮转：运行相同时间后切换
     - 最短剩余时间优先：剩的少优先
     - 高响应比优先：（等待时间 + 要求服务时间）/ 要求服务时间
     - 优先级：选优先级高的
  
  8. **进程终止的方式？**
  
     - 正常退出（5种）：main函数return自然返回、exit()系统调用
     - 异常退出（3种）：
     - [博客-UNIX环境高级编程](https://www.cnblogs.com/nufangrensheng/p/3507921.html)
  
  9. **经典的锁？**
  
     - 读写锁：读读不互斥，读写、写写互斥，写优先于读
  
     - 自旋锁：一直循环尝试获取锁；适用于加锁时间短的场景
  
     - 互斥锁：确保一个同一时间只有一个线程访问临界资源
  
     - 条件变量：利用共享的**全局变量**进行同步
  
     - | 互斥锁                         | 条件变量 |
       | ------------------------------ | -------- |
       | 用来上锁                       | 用来等待 |
       | 线程互斥                       | 线程同步 |
       | 缺点：只有两种状态锁定和非锁定 |          |
  
     - 通常互斥锁和条件变量同时使用：条件不足，线程解开互斥锁并阻塞线程等待条件变化；一旦有一个线程改变了变量，改变条件唤醒被阻塞的线程
  
  10. **孤儿进程、僵尸进程、守护进程**
  
      - 孤儿进程：父进程先退出，子进程还没有退出，托孤给init进程
      - 僵尸进程：子进程已经终止，父进程还没有获取到其状态
        - 如何避免僵尸进程：
        - fork()两次
        - 调用wait/waitpid获取子进程退出状态
        - 忽略SIGCHLD信号
        - 捕获SIGCHLD信号并在捕获程序中调用wait/waitpid函数
        - [讲解](https://www.jb51.net/article/135564.htm)
      - 守护进程：在后台运行，不与任何终端关联的进程；通常情况系统启动时就在运行
        - 如何创建守护进程：
        - 调用fork创建子进程，父进程调用exit退出
        - 调用setsid()使进程成为一个会话组长
        - 将当前目录更改为根目录
        - 重新设置文件权限掩码umask(0)
        - 关闭文件描述符
  
  11. 

# 死锁

- Conception：
  1. 死锁
  1. 银行家算法
- Question：
  1. **死锁？**
     - 多个进程在运行过程中因争夺资源而造成的一种僵局，占有自身资源并请求对方资源
  2. **产生死锁的原因？**
     - 资源分配不当，系统资源不足
     - 程序推进的顺序不合适
  3. **产生死锁的必要条件？**
     - 互斥条件：一段时间内某资源仅为一个进程占用
     - 请求和保持条件：对已获得的资源保持不放
     - 不剥夺条件：获得之后不能被剥夺
     - 环路等待条件：存在环形链
  4. **解决死锁的方法？**
     - 预防死锁
       - 一次性分配所有资源（破坏请求条件）
       - 有其中一个资源得不到，其他的也不给分配（破坏请保持条件）
       - 已经得到部分，但得不到其他，释放拥有的（破坏不可剥夺条件）
       - 给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源（破坏环路等待条件）
     - 避免死锁
       - 在进行资源分配之前预先计算资源分配的安全性，如果会导致系统进入不安全的状态，则分配给进程
       - 解决：银行家算法
     - 检测死锁
       - 首先为每个进程和每个资源指定一个唯一的号码
       - 然后建立资源分配表和进程等待表
     - 解除死锁
       - 剥夺资源
       - 撤销进程
       - 进程回退

# 内存管理

- Conception：
  1. 分页、分段
  1. 缓冲区溢出
  1. 逻辑地址、物理地址
  1. 虚拟内存
  1. 页面置换算法
  1. 外存（磁盘）：分为文件区（离散分配）和对换（连续分配）区
  1. 抖动/颠簸
  
- Question：

  1. **缓冲区溢出？危害？**

     - 缓冲区：暂时放置输入、输出资料的内存
     - 缓冲区溢出：向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖了合法数据
     - 危害：程序崩溃、跳转执行一段恶意代码

  2. **分页、分段？**

     - | 段                               | 页                                   |
       | -------------------------------- | ------------------------------------ |
       | 信息的逻辑单位、根据用户需要划分 | 信息的物理单位，为了管理主存方便划分 |
       | 大小不固定                       | 大小固定，系统决定                   |
       | 向用户提供二维地址空间           | 向用户提供一维地址空间               |

  3. 物理地址、逻辑地址？

     - | 物理地址           | 逻辑地址             |
       | ------------------ | -------------------- |
       | 内存单元真正的地址 | 计算机用户看到的地址 |

  4. **虚拟内存？**

     - 使得应用程序认为拥有连续的可用的内存，实际上，是多个物理内存碎片

  5. **页面置换算法？**

     - 先进先出
     - 最佳置换算法：选未来最远要使用的淘汰，并不可行
     - 最近最久未使用（LRU）
     - 时钟置换：环形链表；第一个次加载页面的时候，页面标记被设置为0，调用内存中驻留的页面时，标记该页面为1；出现缺页时，指针从当前位置循环查找环形链表，如果遇到标记为1的，标记为0，如果遇到标记为0的，置换它
     - 最不常用（LFU）：淘汰访问次数最少的
  
  6. **常见内存分配错误？**
  
     - 内存没有分配成功，确使用了：if(进程检查)
     - 内存分配成功，但未初始化
     - 内存分配成功且初始化，但操作越界
     - 忘记释放内存，内存泄露
     - 释放内存依旧使用：释放后没有置为NULL，产生野指针
  
  7. **外存？内存交换中，被换出的进程保存在哪里？**
  
     - 保存在磁盘也就是外存中，磁盘 = 文件区 + 对换区，进程存放在对换区
  
     - | 文件区         | 对换区       |
       | -------------- | ------------ |
       | 存放文件       | 存放进程数据 |
       | 离散分配       | 连续分配     |
       | 追求空间利用率 | 提高对换速度 |
  
  8. **抖动？颠簸？**
  
     - 抖动/颠簸：刚刚换出的页面马上换入内存，刚刚换入的页面马上换出外存，频繁的页面调度
     - 原因：进程频繁访问的页面数目比分配的物理快多
     - 进程工作集：抖动影响效率，虚拟内存管理器将一定量的内存页驻留在内存中，根据进程工作的指标，动态调整这个页面数量

# 文件管理

- Conception：
  1. 硬链接、软链接
- Question：

# 各种置换算法

- Conception：
  1. 进程调度算法
  2. 页面置换算法
- Question：

# 一些其他问题

- 原子操作是如何实现的：使用总线锁/缓存锁保证原子性[帅地](https://www.iamshuaidi.com/1954.html)

