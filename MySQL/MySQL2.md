# 参考文章

- [整体类：掘金 贾不假](https://juejin.cn/post/6850037271233331208#heading-76)
- [程序员库森](https://github.com/cosen1024/Java-Interview)

# 整体性问题

- Conception：
  1. 架构：客户端、连接器、查询缓存、分析器、优化器、执行器、存储引擎
  2. Mongodb和MySQL区别
  
- Question：
  1. **一条查询语句是怎么执行的？/MySQL架构？**
  
     - 客户端：与连接器建立连接
     - 连接器：查询缓存，命中则返回，没有进入分析器
     - 查询缓存
     - 分析器：分析sql语义
     - 优化器：优化sql语句，选择索引、join表的连接顺序
     - 执行器：权限验证，通过则执行sql
     - 存储引擎：存储数据
  
  2. **一条更新语句是怎么执行的？（两阶段提交）**
  
     - ```sql
       update T set c=c+1 where id=2;
       ```
  
     - 查找id=2，加载到缓存中
  
     - 将c+1并写进数据库，再更新到内存
  
     - 写入redolog（prepare状态）
  
     - 生成binlog，把binlog写入磁盘
  
     - 提交事务，redolog改为commit状态
  
     - 更新完成
  
     - 为什么两阶段提交：
     
     - redolog是恢复没有持久化到磁盘的操作，binlog是恢复到此前的某一状态；
     
     - 先写redo再写bin：进程异常重启，redolog重新恢复把0变为1，binlog没有记录，之后恢复时候还是0
     
     - 先写bin再写redo：redolog没有记录，这一行为0，binlog之后某次恢复时候恢复成了1
     
  3. Mongodb和MySQL区别？
  
     - MongoDB：基于分布式文件存储的数据库，非关系型，Json的存储格式
  
     |              | Mongodb                            | MySQL            |
     | ------------ | ---------------------------------- | ---------------- |
     | 数据库模型   | 非关系型、文档型                   | 关系型           |
     | 成熟度       | 新型数据库，成熟度较低             | 成熟度较高       |
     | 数据处理方式 | 基于内存，热数据在内存中，高速读写 | 不同引擎特点不同 |
     |              |                                    |                  |
     | 缺点         | 不支持事务，开放文档不完善         | 海量数据处理较慢 |
  
     - [参考](https://www.cnblogs.com/king0207/p/13891623.html)
  
  4. 

# 基础/语法问题

- Conception：
  1. 数据库三范式
  2. 反范式
  3. char和varchar
  4. drop、delete、truncate
  5. 存储过程
  6. 巴斯-科德范式（BCNF第三范式的子集）、第四范式(4NF）和第五范式（5NF，又称完美范式）
  
- Question：
  1. **说说三范式？**
     - 第一范式：数据库中的字段具有原子性，不可再分（原子性，否则就不是关系数据库）
     - 第二范式：有主键，非关键字段依赖主键（唯一性，一个表只说明一个事务）
     - 第三范式：非主键字段不能相互依赖（不存在传递关系）
     - 并不是所有的表一定要满足三大范式
     
  1. **反范式？**
  
     - 数据库要求满足三范式，不能有冗余字段
     - 但是有的冗余字段可以方便查询（eg：单价*数量=金额，但是多一列金额可以提高查询速度）
     
  1. **char和varchar区别？**
  
     - char(n)：定长字段
     - varchar：变长字段，占用空间要+1（存长度）
     - 检索效率：char > varchar
     - 如果使用中可以确定某个字段值的长度，可以用char，否则尽量使用varchar
  
  1. **varchar为什么建议不超过255？**
  
     - varchar需要一个字节保存长度
     - 大于255时，长度标识需要两个字节，建立的索引也会失效（表索引的前缀长度最长是767字节，5.6版本之前）
  
  1. **SQL约束（对表中数据的一种约束）？**
  
     - NOT NULL：非空约束
     - UNIQUE：唯一约束
     - PRIMARY KEY：主键约束，不能重复不能为空
     - FOREIGN KEY：外键约束
     - CHECK：检查约束，检查数据表中字段值有效性
     - DEFAULT：默认值约束
  
  1. **drop、delete、truncate区别？**
  
     - |          | DELETE                                   | TRUNCATE                       | DROP                                         |
       | -------- | ---------------------------------------- | ------------------------------ | -------------------------------------------- |
       | 类型     | DML                                      | DDL                            | DDL                                          |
       | 回滚     | 可以                                     | 不可以                         | 不可以                                       |
       | 删除内容 | 表结构还在，删除表的全部或者一部分数据行 | 表结构还在，删除表中所有数据行 | 从数据库删除表，所有数据行，索引和权限也删除 |
       | 删除速度 | 慢，逐行删除                             | 较快                           | 最快                                         |
  
  1. **in和exists区别？**
  
     - IN：查询某个范围内的数据
  
       ```sql
       select * from where field in (value1,value2,value3,…)
       ```
  
     - EXISTS：用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False
  
       ```sql
       SELECT … FROM table WHERE EXISTS (subquery)
       ```
  
     - IN：外表和内表作hash链接
  
     - EXISTS：对外表作loop循环，每次loop循环再对内表进行查询
  
     - 两个表大小相当，效率差别不大
  
     - 一个表大一个表小，子查询表大的用EXISTS，子查询表小的用IN
  
  1. **说说存储过程？**
  
     - 预编译的SQL语句，由一些T-SQL语句组成的代码块，用到这个功能时候调用即可
     - 执行效率高，一个存储过程代替大量T-SQL语句，提高通信效率，确保数据安全
     - 不太推荐存储过程

# 引擎

- Conception：
  1. InnoDB、MyISAM（咪塞姆）、Memory
  
- Question：
  1. InnoDB和MyISAM区别
  
     |          | InnoDB                                                       | MyISAM                                                       | Memory |
     | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------ |
     | 事务     | 支持事务                                                     | 不支持事务                                                   |        |
     | 外键     | 支持外键                                                     | 不支持外键                                                   |        |
     | 索引     | 是聚簇索引，B+tree为索引结构，数据文件和索引绑在一起；不支持全文索引 | 非聚簇索引，B+tree为索引结构，索引和数据文件分离，索引保存的是数据文件的指针；支持全文索引 |        |
     | 文件组成 | frm：表定义文件；idb：数据文件                               | frm：表定义文件；myd：数据文件；myi：索引文件                |        |
     | 锁       | 表、行锁                                                     | 表锁                                                         |        |
     | 主键     | 必须有主键，如果每指定会自己生成默认主键                     | 可以没有                                                     |        |
     | 日志     | redolog                                                      | 没有redolog                                                  |        |
     | 行数     | 不保存具体行数                                               | 一个变量保存了整个表的行数                                   |        |
     
  2. 

# 索引

- Conception：

  1. **数据结构角度：**
  1. B+树索引、Full-Text全文索引、哈希索引、R-Tree索引
  2. **物理存储角度：**
  3. 聚簇索引：叶子节点存数据
  3. 非聚簇索引（辅助索引、二级索引）：叶子节点存主键
  4. **逻辑角度**：
  5. 唯一索引
  6. 普通索引
  7. 主键索引
  8. 单值索引、单列索引
  9. 联合索引、复合索引、多列索引
  10. 覆盖索引：查询语句的结果从索引中就可以取得，不需要回表
  11. 冗余索引、重复索引
  12. **一些规则：**
  13. 最左前缀原则
  13. 索引下推
  14. **不太常见：**
  15. 倒排索引、反向索引
  16. 倒序索引
  17. 前缀索引：把很长字段的前面的一部分作为索引
  18. 空间索引

- Question：

  1. **索引是什么？为什么要有索引？**
  
     - 一个排序的数据结构，提高查询效率，字典中的目录
     - 一种特殊的文件，包含着对数据表里所有记录的引用指针
  
  2. **索引的底层实现？**
  
     - 哈希索引（全文搜索引擎的索引）：将一个字段使用哈希函数映射到一个地址，冲突用拉链法
     - B树索引：
     - B+树索引：
  
  3. **索引为什么用B+树？**
  
     - B树和B+树对比
  
       - B+树只有叶子节点存数据，内部节点不存指向数据的指针，内存节点更小，磁盘能容纳的关键字数量越多，IO读写次数少
       - 方便扫库，只扫描一次叶子节点即可，更适合范围查询；B树的话需要进行中序遍历
  
       ![img](https://upload-images.jianshu.io/upload_images/16722260-c46915a0c91a4757.png)
  
     - Hash与B+树对比：
  
       - 可以快速定位但是没有顺序
       - 只有Memory引擎显式支持哈希索引
       - 适合等值查询，不适合范围查询
       - 大量重复键值时效率低
  
     - 二叉树与B+树对比：
  
       - 树高度不均匀，不能自平衡，IO代价高
  
     - 红黑树和B+树对比：
  
       - 树的高度随着数据量增加而增加，IO代价高
  
  4. **索引的优缺点？**
  
     - 优点：加快检索速度
     - 缺点：时间（创建所以、每次修改数据需要维护索引）；空间（索引文件占用物理空间）
  
  5. **如何创建索引？**
  
     - CREATE TABLE时候
     - ALTER TABLE命令增加索引
     - CREATE INDEX创建索引
  
  6. **创建索引时候需要注意什么？**
  
     - 非空字段：指定列为NOT NULL，MySQL中含有空值的列很难进行查询优化，用0/特殊值/空串替代空值
     - 离散程度大的值（count()函数可以查看差异值）
     - 索引字段小好，IO次数少
  
  7. **创建索引的原则**
  
     - 最左前缀匹配原则
     - =和in可以乱序，查询优化器会优化
     - 尽量选择区分度高的列作为索引（比例越大扫描的次数越少）
     - 索引列不能参与计算
     - 尽量扩展索引，不要新建索引（已经有a，要建a,b，直接修改a）
  
  8. **索引分类？**
  
     - 存储结构：B+树索引、哈希索引、全文索引、RTree索引
     - 物理存储：聚簇索引、非聚簇索引（辅助索引、二级索引）
     - 逻辑角度：
       - 唯一索引、普通索引、主键索引
       - 单值索引/单列索引、联合索引/复合索引/多列索引
       - 覆盖索引、冗余索引、重复索引
     - 不常见：倒排索引、反向索引、倒序索引、前缀索引、空间索引
  
  9. **普通索引和唯一索引怎么选择？**
  
     - 普通索引：更新场景（将数据页读入内存，更新数据页，可用到change buffer优化；唯一索引还需要判断是否唯一）
     - 唯一索引：查询场景（唯一索引扫整张表，查到即返回；普通索引还需要向后遍历）
     - change buffer：数据页在内存中直接更新，不在的话将缓存操作缓存在change buffer，下次访问时候写入页（节省随机读磁盘的IO消耗），普通索引更新可用到，唯一索引不行
  
  9. **什么是回表？**
  
     - 先通过非主键索引找到主键id，再通过主键从主键索引里取出数据
  
  11. **聚簇索引和非聚簇索引？**
  
      - | 聚簇索引                   | 非聚簇索引                           |
        | -------------------------- | ------------------------------------ |
        | 索引的叶子节点存储了数据   | 索引的叶子节点存储了主键值           |
        | 不需要回表，直接找到了数据 | 需要回表（如果没有发生覆盖情况的话） |
  
      - MyISAM无论主键索引还是二级索引都是非聚簇索引，InnoDB主键索引是聚簇索引，二级索引是非聚簇索引
  
      - 自己建的索引基本都是非聚簇索引
  
  12. **非聚簇索引一定会回表吗？**
  
      - 不一定，如果包含了所有需要查询字段的值（覆盖索引）就不回表
  
  13. **联合索引？为什么注意联合索引的顺序？**
  
      - 使用多个字段同时建立一个索引
      - 需要安装建立索引时的顺序挨个使用，否则无法命中（原因：先按第一列排序再按第二列排序）；将频繁使用的列放在前面
  
  12. **前缀索引？**
  
      - 原因：索引字段太长占据空间不利于维护
      - 做法：把某个列开始的部分字符串作为索引值
      
  12. **说说最左前缀原则？**
  
      - 最左面的一个列不触发，之后的索引都无法触发
  
      - ```sql
        # 存在(a,b,c)的索引
        #a,b走索引
        where a = 1 and b = 1 
        #b没触发，c也不走索引
        where a = 1 and c = 1
        #a没触发，b,c都不走索引
        where b = 1 and c = 1
        ```
  
  16. **说说索引下推？**
  
      - ```sql
        # 有(name,age)的联合索引
        select * from userinfo where name like "ming%" and age=20;
        ```
  
      - 5.6之前返回name符合的结果，拿着id值再去回表查询
  
      - 5.6开始索引内部判断age是否为20
  
      - 减少了回表次数
  
      - 索引下推InnDB引擎**只适用于二级索引**/非主键索引（聚簇索引会将整行数据读到缓冲区，索引下推减少IO次数就失去了意义，数据已经在内存中，不用再去读取了）
  
      - 索引下推InnDB引擎只适用于二级索引（聚簇索引会将整行数据读到缓冲区，索引下推减少IO次数就失去了意义，数据已经在内存中，不用再去读取了）
  
  17. **怎么查看有没有用到索引？**
  
      - EXPLAIN语句
      - possible_key：查询中可能用到的索引
      - key：当前查询真正使用的索引
  
  18. **为什么推荐使用自增长主键作为索引？**
  
      - 自增主键是连续的
      - 每次插入数据都是插到最后，减少列分列和移动的频率
  
  19. **使用索引一定能提高查询性能吗？**
  
      - 通过索引查询通常比全表扫描快
      - 不一定能够提高查询性能，索引需要维护
  
  20. **什么时候索引失效？什么时候不走索引？**
  
      - 最左前缀法则
      - 范围条件（between、>、<、in）
      - 类型不一致
      - 计算函数导致
      - 运算符（+-*/!）导致
      - OR引起
      - 模糊搜索：使用like以通配符**开头**（‘%字符串’）
      - 索引字段是字符串，但查询时不加单引号
      - NOT IN、NOT EXISTS导致索引失效

# 事务

- Conception：
  1. 四个特性（ACID）
  2. 并发事务访问相同记录的情况（读读，读写写读，写写）
  3. 脏写脏读、不可重复读、幻读
  4. 4个隔离级别
  5. 当前读、快照读
  6. MVCC
  6. READ VIEW
  
- Question：
  1. **事务是什么？事务的四个特性？**
  
     - 事务：一系列操作必须全部完成，有一个失败则全部失败，数据库并发控制的基本单位
     - 原子性：要么全部执行，要不全不执行
     - 一致性：事务前后数据完整性必须一致
     - 隔离性：各个事务之间不能被互相干扰
     - 持久性：事务完成后改变是永久性的
  
  1. **事务四种隔离级别和三种读的问题解决了哪些？**
  
     - 事务隔离机制的实现基于：锁+MVCC
  
     - 读未提交：能够读到没有提交的数据
  
     - 提交读：一个事务只能读到已经提交的数据
  
     - 可重复读：同一事务内，任意时刻读到的数据是一样的
  
     - 串行化：不管多个事务，都是按序一个一个执行（分布式事务）
  
     - |          | 脏读   | 不可重复读 | 幻读   | 如何实现         |
       | -------- | ------ | ---------- | ------ | ---------------- |
       | 读未提交 | 可能   | 可能       | 可能   | 直接读取最新版本 |
       | 提交读   | 不可能 | 可能       | 可能   | MVCC             |
       | 可重复读 | 不可能 | 不可能     | 可能   | MVCC             |
       | 串行化   | 不可能 | 不可能     | 不可能 | 加锁             |
  
  1. **说说脏读、不可重复读、幻读？**
  
     - 脏读：读到了未提交的数据，回滚后读到的数据不一致
     - 不可重复读：针对修改，前后读到的数据不一致
     - 幻读：针对增加、删除，前后读到的行数不一样
  
  1. **事务的实现原理/MySQL事务日志说一下？**
  
     - 基于redo log和undo log
     - redo log：先将事务的所有操作写入redo log，保证原子性和持久性
     - undo log：可以撤销到事务开始前的状态，保证一致性
  
  1. **可重复读解决幻读了吗？**
  
     - 解决了**读数据**的幻读，没解决**修改数据**的幻读(update)，要解决就要串行化/MVCC + 间隙锁
     
  1. **在事务中可以混合使用存储引擎吗？**
  
     - MySQL服务器不管理事务，存储引擎层实现事务
     - 尽量不要使用
     - 需要回滚时会出现问题
     - 为每张表选择合适的存储引擎非常重要
  
  1. **当前读、快照读？**
  
     - 当前读：读取的是记录的最新版本；读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁
     - 当前读通过 next-key 锁(行记录锁+间隙锁)；适用于 insert，update，delete， select ... for update， select ... lock in share mode 语句，以及加锁了的 select 语句
     - 快照读：照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本
     - 快照读基于 MVCC 和 undo log 来实现，适用于select语句
  
  1. **什么是MVCC？**
  
     - 多版本并发控制（Multi-Version Concurrency Control）
     - 用于支持**提交读**和**可重复读**的实现
     - 通过保存数据在某个时间点的快照来实现的，事务开始的时间不同，每个事务对于同一张表，同一时刻看到的数据可能是不一样的
     - MVCC通过保存数据的历史版本，根据比较版本号来处理数据的是否显示，从而达到**读取**数据的时候不需要加锁就可以保证事务隔离性的效果，避免因为写锁的阻塞而造成读数据的并发阻塞问题
  
  1. **MVCC的实现原理？**
  
     - 隐藏回滚指针，指向上一个版本
     - A要更新时候，将原纪录放进undo log里，回滚指针指向这个记录；如果事务执行过程中，其他事务要查询，就去查指针指向的undo log
     
  1. **Read View**
  
     - MVCC内部使用的一致性读快照/读视图称为**Read View**
     - READ VIEW有四个数据，有一个版本链（创建readview时候活跃的事务：在动的事务）
     - 当前状态下访问某个数据，需要将其版本号与readview中的版本号进行对应，从而决定能不能访问
     - 自己的最新的更新总是可见
     - 版本未提交：不可见
     - 版本已提交，但是是在视图创建后提交的：不可见
     - 版本已提交，而且是在视图创建前提交的：可见
     - [讲解](https://zhuanlan.zhihu.com/p/110263562)
     - RC隔离级别：每次读取数据前，都生成一个readview；
     - RR隔离级别：在第一次读取数据前，生成一个readview；
     - READ COMMITTED：只承认在语句启动前就已经提交完成的数据
     - REPEATABLE READ：只承认在事务启动前就已经提交完成的数据

# 日志

- Conception：
  1. Write Ahead Loging技术
  2. 逻辑日志、物理日志
  3. redo log
  4. undo log
  5. bin log
  6. relay log、slow query log、error log
  7. gereral log
  7. 两阶段提交
  9. 二进制日志（binary log）
  
- Question：
  1. **WAL是什么？有什么好处？**
     - Write-Ahead Logging：所有的修改都先被写入到日志（log）中，然后再写磁盘。如果事务失败，WAL中的记录会被忽略，如果成功，某个时间点写回到数据库文件，提交修改。
     - 保证原子性、持久性
     - 好处：读写可以并发执行，不会相互阻塞（写写依旧阻塞）；先写log再写磁盘，随机写变为数据写，IO次数降低；可以用日志恢复磁盘数据
     
  2. **bin log是什么？redo log是什么？undo log是什么？relay log是什么？**
  
     - |          | bin log                                        | redo log                                                     |
       | -------- | ---------------------------------------------- | ------------------------------------------------------------ |
       | 日志类型 | 逻辑日志（记的是SQL语句）                      | 物理日志（记的是修改后的数据）                               |
       | 写的方式 | 追加写，不会覆盖                               | 循环写，空间会被用完                                         |
       | 实现层   | Server层实现，所有引擎都可以                   | InnoDB特有                                                   |
       |          | 没有 crash-safe 的能力，只能用于归档           | 保证crash-safe能力（进程异常重启，系统检查redolog，将未写入MySQL的数据恢复进去） |
       | 写入时机 | 事务提交时一次性写入                           | 事务开始就逐步写入                                           |
       | 作用     | 主从复制、数据恢复（**恢复**到**某个时间点**） | 确保事务的持久性（redo log来记录已成功提交事务的修改信息，redolog把**没有持久化到磁盘的数据**进行**恢复**） |
       | tips     |                                                | mysql闲下来的时候才将redolog写入到磁盘中                     |
  
     - binlog三种格式：statement（基于SQL语句的模式）、row（记录的是行的变化）、mixed（根据语句选择是statement还是row）
  
     - undo log：InnoDB 存储引擎的日志，保证原子性，记录事务发生前的数据的一个版本，用于回滚，提供MVCC；主要作用：事务回滚、MVCC
  
     - | redo log                                             | undo log                 |
       | ---------------------------------------------------- | ------------------------ |
       | 数据修改前先写入redo log，断电意外之后，可以继续完成 | 意外之后撤销回之前的状态 |
       | 物理日志                                             | 逻辑日志                 |
       | 保证事务原子性和持久性                               | 保证一致性               |
       
     - relay log：中继日志，主从复制时候用到，中介临时的日志文件，存储master节点同步过来的binlog日志内容
  
     - ![图片](https://mmbiz.qpic.cn/mmbiz_png/9dwzhvuGc8aP3ZujaVhV3NucRZQWuMRAn8PkN3k75QWLXcJvvIQRad52fZsxTcOUj4oJfeSod4xx4StbpmgKEg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
  
  3. **两阶段提交？Innodb事务为什么要两阶段提交**？
  
     - ```sql
       update T set c=c+1 where id=2;
       ```
  
     - 查找id=2，加载到缓存中
  
     - 将c+1并写进数据库，再更新到内存
  
     - 写入redolog（prepare状态）
  
     - 生成binlog，把binlog写入磁盘
  
     - 提交事务，redolog改为commit状态
  
     - 更新完成
  
     - 为什么两阶段提交：
  
     - redolog是恢复没有持久化到磁盘的操作，binlog是恢复到此前的某一状态；
  
     - 先写redo再写bin：进程异常重启，redolog重新恢复把0变为1，binlog没有记录，之后恢复时候还是0
  
     - 先写bin再写redo：redolog没有记录，这一行为0，binlog之后某次恢复时候恢复成了1
     
  4. **二进制日志记录了什么信息（binary log）？**
  
     - 记录修改或可能引起数据变更的MySQL语句，不记录select和show语句
     - 还记录语句发生时间、执行时长、操作数据等信息

# 锁

- Conception：
  1. 全局锁
  2. 粒度分：
  3. 表锁（表锁、MDL、意向锁、AUTO-INC锁）
  4. 行锁（Record Lock记录锁、Gap Lock间隙锁、Next-key Lock临键锁）
  5. 页锁
  6. 属性/类别分：
  7. 读锁|共享锁、写锁|排他锁
  8. 乐观锁、悲观锁
  9. 死锁
  
- Question：
  1. **锁的分类？**
  
     - 粒度分：
  
       | 行锁                 | 表锁                 | 页锁                     |
       | -------------------- | -------------------- | ------------------------ |
       | 粒度最细             | 粒度最大             | 粒度介于行级锁和表级锁   |
       | 会出现死锁           | 不会出现死锁         | 会出现死锁               |
       | 加锁开销大，并发度高 | 加锁开销小，并发度低 | 介于两者之间，并发度一般 |
  
     - 类别分：
  
       | 共享锁/读锁    | 排他锁/写锁 |
       | -------------- | ----------- |
       | 可以同时加多个 | 只能加一个  |
  
     - | 乐观锁                   | 悲观锁           |
       | ------------------------ | ---------------- |
       | 假设不会发生冲突         | 假设会发生冲冲突 |
       | 多读场景                 | 多写场景         |
       | 省去锁的开销，加大吞吐量 | 降低了性能       |
  
  1. **表级锁？**
  
     |          | 表锁                       | MDL（MetaData Lock）                                  | 意向锁                                                       | 自增锁AUTO-INC锁                                             |
     | -------- | -------------------------- | ----------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
     | 含义     |                            | 对数据库表操作时候，自动给这个表加MDL，事务提交后释放 | 向数据库中的行加共享/独占锁之前，数据库自动申请表的意向锁    | 专门针对事务插入AUTO_INCREMENT类型的列，一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值 |
     | 作用     |                            |                                                       | 保证用户对当前表操作时，防止其他线程对**表结构**的改变       | 加速判断表里是否有记录被加锁                                 |
     | 使用方法 | lock table xxx read/write; |                                                       | select ... lock in share mode / for update;（检索行时的语句，数据库自己加意向共享锁 / 意向独占锁） | innodb_autoinc_lock_mode配置，，可以调节与改变该锁的模式与行为 |
  
  1. **行级锁？**
  
     |      | Record Lock | Gap Lock                     | Next-key Lock                                      |
     | ---- | ----------- | ---------------------------- | -------------------------------------------------- |
     | 含义 | 记录锁      | 锁定一个范围，不包含记录本身 | Record Lock + Gap Lock锁定一个范围并且锁定记录本身 |
     | 区间 |             | 前开后开                     | 前开后闭                                           |
  
     - 行级锁加锁规则（小林coding）
       - 对记录加锁的基本单位是Next-key Lock，某些情况下会退化成记录锁和间隙锁
       - 唯一索引等值查询：
         - 当查询的记录是存在的，next-key lock 会退化成「记录锁」。
         - 当查询的记录是不存在的，next-key lock 会退化成「间隙锁」。
       - 非唯一索引等值查询：
         - 当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。
         - 当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。
       - 非唯一索引和主键索引的范围查询的加锁规则不同之处在于：
         - 唯一索引在满足一些条件的时候，next-key lock 退化为间隙锁和记录锁。
         - 非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁。
  
  1. **为什么加锁？**
  
     - 并发情况下产生多个事务同时存取同一数据的情况，不加控制就会产生读取或存储不正确，破坏一致性
     - 保证多用户环境下保证数据库完整性和一致性
  
  1. **InnoDB行锁怎么实现的？** 
  
     - 通过给索引上的索引项加锁来实现
     - 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！
  
  1. **死锁？**
  
     - 多个事务在同一资源上互相占用，锁定对方请求的资源，恶性循环
     - 解决死锁方法：一个事务中尽可能一次锁定所需要的所有资源；升级锁的粒度，通过表级锁减少死锁产生概率；不同程序并发使用多个表，尽量约定以相同的顺序
  
  1. **隔离级别与锁的关系？**
  
     - 读未提交：不加共享锁
     - 读提交：加共享锁，语句执行完后释放
     - 可重复读：加共享锁，事务完成前不释放
     - 串行化：锁定整个范围的键，一直持有锁直到事务完成
  
  1. **优化锁的意见？**
  
     - 设计索引，尽量用索引访问数据，加锁更加准确
     - 事务大小合理，一次性请求足够的锁
     - 查询时候不是必要不要加锁
     - 不同程序并发使用多个表，尽量约定以相同的顺序
     - 特殊情况用表锁避免死锁

# 键

- Conception：
  1. 超键、候选键、主键、外键
- Question：
  1. **说说超键、候选键、主键、外键？**
     - 超键：能唯一标识元组的属性集
     - 候选键：最小超键
     - 主键：关系模式中用户正在使用的候选键、一个数据列只能有一个主键，且不能缺失不能为空值（NULL）
     - 外键：当前表中存在的另一个表的主键
  2. **为什么推荐使用自增 id 作为主键？**
     - 普通索引的B+树上叶子节点存的是主键索引的值，会导致索引文件存储空间大
     - 自增id新增时直接插入到页尾，顺序插入即可，减少页分裂维护的成本

# 分区分库分表

- Conception：
  1. 分区
  2. 分表（垂直分表、水平分表）
  3. 分库（垂直分库、水平分库）
- Question：
  1. **为什么分表？为什么分库？**
     - 单表数据量太大，根据某个列查询对对应的表操作即可
     - 用户请求并发量太大，访问一个库即可
  2. **垂直拆分？水平拆分？**
     - 垂直拆分：每个库表的结构不同；将访问频率低的放到一个表中，访问频率高的放到另一个表中，缓存一次性命中的越多
     - 水平拆分：每个库的表结构相同，数据不同
  3. **分库分表方式？**
     - 按照range范围划分：少用，容易产生热点问题
     - 某个字段hash之后均匀分散：常用
  4. **分库分表中间件？**
     - cobar（阿里）、mycat（基于cobar改造）、atlas（360开源）

# 主从复制（同步）

- Conception：
  1. 主从复制
  2. 读写分离
  3. 主从延迟
- Question：
  1. **主从如何同步数据？（讲讲那个图）**
     - ![图片](https://mmbiz.qpic.cn/mmbiz_png/9dwzhvuGc8aP3ZujaVhV3NucRZQWuMRAn8PkN3k75QWLXcJvvIQRad52fZsxTcOUj4oJfeSod4xx4StbpmgKEg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
     - master将更新的时间写入到binlog中
     - master创建log dump线程通知slave需要更新数据
     - slave发起请求，将binlog内容存到本地relaylog中
     - slave开启SQL线程执行relaylog中的内容，完成主从同步
  2. **同步策略**
     - 全同步复制：主库强制同步日志到从库，等全部从库执行完才返回客户端，性能差
     - 半同步复制（semi-sync）：主库收到至少一个从库确认就认为操作成功，从库写入日志成功返回ack确认
  3. **主从同步目的/作用**
     - 读写分离
     - 数据备份
     - 高可用：主服务器宕机，从服务器充当主服务器，保证正常运行
  4. **主从复制涉及到哪三个线程？**
     - bin log线程：主库记录改变放入bin log中
     - IO线程：丛库从bin log拉取内容到relay log中
     - sql执行线程：从库执行relay log同步数据
  4. **主从延迟原因？怎么解决？**
     - 并行复制：MySQL 5.6 版本以后，提供了一种**并行复制**的方式，通过将 SQL 线程转换为多个 work 线程来进行重放（解决主从同步时延问题）
     - 半同步复制：主库收到至少一个ack就认为写操作完成（解决主库数据丢失问题）
     - 提高机器配置
     - 避免单表单库太大
     - 避免长事务
     - 避免让数据库做大量运算
     - 对延迟敏感的业务，直接用主库读

# 问题

- Question：
  1. **为什么一条sql语句查询一直慢？**
     - 没有用到索引，索引失效了
     - 优化器用错了索引，force index强制走索引
     - 数据量太大
  1. **为什么一条sql语句查询偶尔慢？**
     - 刷新脏页（内存数据页和磁盘数据页内容不一致）：刷脏页场景：redolog写满了，停止更新操作；系统内存不足，淘汰数据页；空闲时自动刷脏页
     - 没有拿到锁，在等待锁
  1. **删除数据表大小没变？**
     - 删除数据行并不是真正的删除，是逻辑删除，InnoDB 仅仅是将其标记成可复用（只限于符合范围条件的数据复用）
     - 删掉一整页，整个数据页可以被复用（任何位置都可以复用）
  1. **为什么不要使用长事务？**
     - 并发情况下，数据库连接池容易被撑爆
     - 占用锁资源，造成阻塞和超时
     - 造成主从延迟
     - 回滚时间长
     - undolog越来越长
  1. **数据库CPU飙升到500%怎么处理？**
     - linux top命令查看是不是MySQL导致
     - 如果是MySQL造成，show processlist找出消耗高的sql，看看是不是索引缺失或者数据量太大
     - kill调这些线程，调整后重跑
     - 限制并发连接数
  1. **如何定位及优化SQL语句的性能问题？**
     - 使用执行计划，EXPLAIN命令
  1. **超大分页怎么处理？**
     - 靠缓存，可预测性的提前查到内容，缓存到redis
  1. **慢查询？怎么优化？**
     - 分析语句
     - 分析语句的执行计划
     - 表中数据太大可以横向或纵向分表
  1. **如果查询很慢，怎么实时的查询那些语句慢？**
     - show full processlist \G+开启查询日志
  1. 

# 优化

- Question：
  1. **说说sql调优思路？**
     - 索引：建索引时候选择合适字段；利用好索引下推，覆盖索引等功能；普通/唯一索引
     - 查询：避免索引失效；force index防止选错索引；小表驱动大表
     - 表结构：类型、大小选择；合理的增加冗余字段；新建字段一定要有默认值
     - 分库分表
  2. **大表数据查询怎么优化？**
     - 优化sql语句，用索引
     - 加缓存：memcached、redis
     - 主从复制、读写分离
     - 水平切分、垂直切分
  3. **数据库设计方案优化？**
     - 字段多的进行分表
     - 增加中间表
     - 增加冗余字段
  4. **关联查询如何优化？**
     - ON或者USING子句中是否有索引
     - GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引
  5. **如何优化查询过程中的数据访问？**
     - 避免使用SELECT *返回全部列
     - 避免检索大量超过需要的数据（太多列）
     - 可以缓存数据，下次直接读取缓存
     - 改变表的结构
  6. [explain优化](https://juejin.cn/post/6844904163969630221)

# 一些我暂时不知道放在哪的点

- ？

  1. buffer pool（moon聊技术34）

     - 一块内存区域，为了提高数据库的性能，数据库操作数据的时候，把硬盘上的数据加载到 buffer pool，不直接和硬盘打交道，操作的是 buffer pool 里面的数据，数据库的增删改查都是在 buffer pool 上进行
     - buffer pool 里面缓存的数据内容也是一个个数据页
     - 其中**「有三大双向链表」**:

     - **「free 链表」**

     - - 用于帮助我们找到空闲的缓存页

     - **「flush 链表」**

     - - 用于找到脏缓存页，也就是需要刷盘的缓存页

     - **「lru 链表」**

     - - 用来淘汰不常被访问的缓存页，分为热数据区和冷数据区，冷数据区主要存放那些不常被用到的数据

     - 预读机制:

     - Buffer Pool 有一项特技叫预读，存储引擎的接口在被 Server 层调用时，会在响应的同时进行预判，将下次可能用到的数据和索引加载到 Buffer Pool

  2. 

  

# 一些其他概念

- Conception：
  1. mysql 的sql 类型
     - 一、数据定义语言 DDL：Create、Drop、Alter 操做。用于定义库和表结构的。sql
     - 二、数据查询语言 DQL：select。用于查询数据的。数据库
     - 三、数据操纵语言 DML：insert、update、delete。对行记录进行增删改操做。session
     - 四、数据控制语言 DCL：grant、revoke、commit、rollback。控制数据库的权限和事务
     - [DDL, DML, DCL, TCL](https://www.cnblogs.com/heyonggang/p/9284271.html)

- 
- [T-SQL](https://blog.csdn.net/weixin_37519752/article/details/80913773?spm=1001.2101.3001.6650.3&utm_medium=distribute.wap_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.wap_blog_relevant_default&depth_1-utm_source=distribute.wap_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.wap_blog_relevant_default)

